<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>domino</title>
    <script id="data" type="text/json">{
    "editable": true, 
    "cards": {
        "0": {"text": "hello", "type": "red"}
    }, 
    "views": [
        {"card": "0", "cell": [0, 0]}
    ]
}

    </script>
    <link href="https://fonts.googleapis.com/css?family=Lora&display=swap" rel="stylesheet">
    <style>:root {
    --light: rgb(255, 245, 209);
    --dark: rgb(240, 248, 255);
    --red: #d11305;
    --green: #006951;
    --blue: #162dab;
  
    --red-stiple: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAHUlEQVQYV2O8JMKapvfm9ywGKGCEMTAEYCoxVAAAT4UIBcKIFHsAAAAASUVORK5CYII=);
    --green-stiple: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAHElEQVQYV2NkyOJpYJj2pYEBChhhDEwBqEoMFQD4ngYFtMbpQAAAAABJRU5ErkJggg==);
    --blue-stiple: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAHElEQVQYV2NkSLmZxjBHfRYDFDDCGJgCUJUYKgD+BgYFL5bp8wAAAABJRU5ErkJggg==);
    --black-stiple: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAHElEQVQYV2NkYGBIY2BgmMUABYwwBjYBsEoMFQBSHgIFwNTCZwAAAABJRU5ErkJggg==);

    --card-width: 15rem;
    --card-height: calc(var(--card-width) * .6);
}

.black { background: var(--black-stiple) repeat; }
.red   { background: var(--red-stiple)   repeat; }
.green { background: var(--green-stiple) repeat; }
.blue  { background: var(--blue-stiple)  repeat; }

/* hidden elements should be hidden regardless of their display style */
[hidden] { 
    display: none !important; 
}

.skiptransition {
    transition: none !important;
}

.no-select {
    -webkit-tap-highlight-color: transparent;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}

html, body {
    position: absolute;
    margin: 0;
    width: 100vw;
    height: 100vh;

    overflow: hidden;
}

html {
    background: var(--light);

    font-family: lora;
    font-size: 1.1em;
}

button, textarea {
    font-family: lora;
    font-size: 1em;
}

#screen {
    position: absolute;
    margin: 0;
    width: 100vw;
    height: 100vh;
    cursor: pointer;
}

main {
    transition: transform .2s ease-in-out;
    width: 0;
    height: 0;
}

.screen {
    pointer-events: auto;
    cursor: pointer;
    
    position: absolute;
    box-sizing: border-box;
    width: 100vw;
    height: 100vh;
    background-color: rgb(0, 0, 0, .25);
}

.full-panel {
    cursor: auto;
    box-sizing: border-box;

    margin: auto;

    padding: 2em;

    width: 40em;
    height: 100%;
    max-width: 100%;

    background-color: var(--light);

    overflow: auto;
}

#editor-panel {
    width: calc(var(--card-width));
    position: absolute;
    padding: 1em;
    
    background: var(--dark);
    pointer-events: initial;

    left: 50%;
    transform: translateX(-50%);
    bottom: 0;
    margin: 0;

    max-width: 100%;
}

#editor-panel > h3 {
    margin-top: 0;
}

#content-input {
    padding: 1em;
    width: calc(var(--card-width) - 2em);
    height: calc(var(--card-height) - 2em);

    display: block;
    border: none;
    border-bottom: 2px solid black;
    margin-bottom: 1em;
}

#type-select {
    height: 2em;
    margin-bottom: 1em;
    display: grid;
    column-gap: .5em;
}

.type-button {
    height: 100%;
    grid-row: 1;
    border-bottom: 1px solid black;
    cursor: pointer;
}

.type-button:hover {
    height: calc(100% + .5em);
}

.type-button.selected {
    height: calc(100% + .5em);
}

.card {
    position: absolute;
    cursor: pointer;

    transition: transform .2s ease-in-out;

    padding: 1em;
    width: calc(var(--card-width) - 2em);
    height: calc(var(--card-height) - 2em);

    display: inline-block;
    margin: 0 0 1em;
    word-wrap: break-word;

    border-bottom: 2px solid black;

    text-shadow: 
        0 0 3px var(--light), 
        0 0 3px var(--light), 
        0 0 3px var(--light), 
        0 0 3px var(--light),
        0 0 3px var(--light), 
        0 0 3px var(--light), 
        0 0 3px var(--light), 
        0 0 3px var(--light);
}

.card::selection {
    background: Highlight;
    color: HighlightText;
    text-shadow: none;
}

.card > h3 {
    display: inline;
    font-size: 1em;
}

.card > h3::after {
    font-weight: normal;
    content: " ‚Äî ";
}

#version {
    float: right;
}

.icon-bar {
    cursor: unset;
    position: absolute;

    font-size: 1.5rem;

    display: grid;
    column-gap: .5em;
    margin: 0;
}

.icon-bar > button {
    width: 2em;
    height: 2em;
    grid-row: 1;

    padding: 0;
    text-align: center;
}

#cardbar {
    font-size: 1rem;

    left: 50%;
    transform: translate(-50%, 50%);
    bottom: 0;
}

#cardbar > button {
    border: none;
    background: none;
    text-shadow: 
    0 0 3px var(--light), 
    0 0 3px var(--light), 
    0 0 3px var(--light), 
    0 0 3px var(--light),
    0 0 3px var(--light), 
    0 0 3px var(--light), 
    0 0 3px var(--light), 
    0 0 3px var(--light);
}

#toolbar {
    left: 50%;
    transform: translate(-50%, 0);
    bottom: 0;
    
    margin-bottom: .5em;
}

#project-menu {
    margin-top: 1em;
    display: grid;
    column-gap: 1em;
}

#project-menu > button {
    grid-row: 1;
}

    </style>
    <script>const makeCounter = (count=0) => () => count++;
const remToPx = em => emToPx(document.documentElement, em);
const emToPx = (element, em) => Math.round(em * parseFloat(getComputedStyle(element).fontSize));

function toggleFullscreen() {
    if (document.fullscreenElement) {
        return document.exitFullscreen();
    } else {
        return document.documentElement.requestFullscreen({ navigationUI: 'hide' });
    }
}

async function textFromFile(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onerror = reject;
        reader.onload = () => resolve(reader.result);
        reader.readAsText(file); 
    });
}

async function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function killEvent(event) {
    event.stopPropagation();
    event.preventDefault();
}

function eventToElementPixel(event, element) {
    const rect = element.getBoundingClientRect();
    return [event.clientX - rect.x, event.clientY - rect.y];
}

function getElementCenter(element) {
    return [element.clientWidth / 2, element.clientHeight / 2];
}

function setElementDragoverDropEffect(query, effect) {
    addListener(query, 'dragover', event => {
        killEvent(event);
        event.dataTransfer.dropEffect = effect;
    });
}

function queryToElement(query) {
    return (query instanceof Element) ? query : document.querySelector(query);
}

function cloneTemplateElement(query) {
    const template = queryToElement(query);
    const clone = template.cloneNode(true);
    clone.removeAttribute('id');
    return clone;
}

function addListener(query, type, listener) {
    queryToElement(query).addEventListener(type, listener);
}

function coordsAreEqual(a, b) {
    if (a.length !== b.length) 
        return false;

    for (let i = 0; i < a.length; ++i)
        if (a[i] !== b[1])
            return false;
    
    return true;
}

function coordsToKey(coords) {
    return coords.join(',');
}

class CoordStore {
    constructor() { this.store = new Map(); }
    get size() { return this.store.size; }
    get(coords) { return this.store.get(coordsToKey(coords)); }
    set(coords, value) { return this.store.set(coordsToKey(coords), value); }
    delete(coords) { return this.store.delete(coordsToKey(coords)); }
    has(coords) { return this.store.has(coordsToKey(coords)); }
}

// based on https://www.redblobgames.com/grids/hexagons/
class HexGrid {
    constructor(cellSize) {
        this.cellSize = cellSize;
    }

    cellToPixel(cellCoords) {
        const [q, r] = cellCoords;
        const [w, h] = this.cellSize;

        const x = q * w;
        const y = (r + q / 2) * h;
        return [x, y];
    }

    pixelToCell(pixelCoords) {
        const [x, y] = pixelCoords;
        const [w, h] = this.cellSize;
        // pixel to axial coordinates
        const q = x / w;
        const r = y / h - q / 2;
        // convert axial to cube coordinates
        const [cx, cy, cz] = [q, r, -q-r];
        // determine rounding error
        let [rx, ry, rz] = [cx, cy, cz].map(Math.round);
        const [dx, dy, dz] = [rx - cx, ry - cy, rz - cz].map(Math.abs);
        // recompute worst coordinate from others
        if (dx > dy && dx > dz) {
            rx = -ry-rz
        } else if (dy > dz) {
            ry = -rx-rz
        } else {
            rz = -rx-ry
        }
        // return axial components
        return [rx, ry];
    }
}

    </script>
    <script>var DragDropTouch;!function(t){"use strict";var e=function(){function t(){this._dropEffect="move",this._effectAllowed="all",this._data={}}return Object.defineProperty(t.prototype,"dropEffect",{get:function(){return this._dropEffect},set:function(t){this._dropEffect=t},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"effectAllowed",{get:function(){return this._effectAllowed},set:function(t){this._effectAllowed=t},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"types",{get:function(){return Object.keys(this._data)},enumerable:!0,configurable:!0}),t.prototype.clearData=function(t){null!=t?delete this._data[t]:this._data=null},t.prototype.getData=function(t){return this._data[t]||""},t.prototype.setData=function(t,e){this._data[t]=e},t.prototype.setDragImage=function(t,e,n){var s=i._instance;s._imgCustom=t,s._imgOffset={x:e,y:n}},t}();t.DataTransfer=e;var i=function(){function t(){if(this._lastClick=0,t._instance)throw"DragDropTouch instance already created.";var e=!1;if(document.addEventListener("test",function(){},{get passive(){return e=!0,!0}}),"ontouchstart"in document){var i=document,n=this._touchstart.bind(this),s=this._touchmove.bind(this),o=this._touchend.bind(this),r=!!e&&{passive:!1,capture:!1};i.addEventListener("touchstart",n,r),i.addEventListener("touchmove",s,r),i.addEventListener("touchend",o),i.addEventListener("touchcancel",o)}}return t.getInstance=function(){return t._instance},t.prototype._touchstart=function(e){var i=this;if(this._shouldHandle(e)){if(Date.now()-this._lastClick<t._DBLCLICK&&this._dispatchEvent(e,"dblclick",e.target))return e.preventDefault(),void this._reset();this._reset();var n=this._closestDraggable(e.target);n&&(this._dispatchEvent(e,"mousemove",e.target)||this._dispatchEvent(e,"mousedown",e.target)||(this._dragSource=n,this._ptDown=this._getPoint(e),this._lastTouch=e,e.preventDefault(),setTimeout(function(){i._dragSource==n&&null==i._img&&i._dispatchEvent(e,"contextmenu",n)&&i._reset()},t._CTXMENU),t._ISPRESSHOLDMODE&&(this._pressHoldInterval=setTimeout(function(){i._isDragEnabled=!0,i._touchmove(e)},t._PRESSHOLDAWAIT))))}},t.prototype._touchmove=function(t){if(this._shouldCancelPressHoldMove(t))this._reset();else if(this._shouldHandleMove(t)||this._shouldHandlePressHoldMove(t)){var e=this._getTarget(t);if(this._dispatchEvent(t,"mousemove",e))return this._lastTouch=t,void t.preventDefault();this._dragSource&&!this._img&&this._shouldStartDragging(t)&&(this._dispatchEvent(t,"dragstart",this._dragSource),this._createImage(t),this._dispatchEvent(t,"dragenter",e)),this._img&&(this._lastTouch=t,t.preventDefault(),e!=this._lastTarget&&(this._dispatchEvent(this._lastTouch,"dragleave",this._lastTarget),this._dispatchEvent(t,"dragenter",e),this._lastTarget=e),this._moveImage(t),this._isDropZone=this._dispatchEvent(t,"dragover",e))}},t.prototype._touchend=function(t){if(this._shouldHandle(t)){if(this._dispatchEvent(this._lastTouch,"mouseup",t.target))return void t.preventDefault();this._img||(this._dragSource=null,this._dispatchEvent(this._lastTouch,"click",t.target),this._lastClick=Date.now()),this._destroyImage(),this._dragSource&&(t.type.indexOf("cancel")<0&&this._isDropZone&&this._dispatchEvent(this._lastTouch,"drop",this._lastTarget),this._dispatchEvent(this._lastTouch,"dragend",this._dragSource),this._reset())}},t.prototype._shouldHandle=function(t){return t&&!t.defaultPrevented&&t.touches&&t.touches.length<2},t.prototype._shouldHandleMove=function(e){return!t._ISPRESSHOLDMODE&&this._shouldHandle(e)},t.prototype._shouldHandlePressHoldMove=function(e){return t._ISPRESSHOLDMODE&&this._isDragEnabled&&e&&e.touches&&e.touches.length},t.prototype._shouldCancelPressHoldMove=function(e){return t._ISPRESSHOLDMODE&&!this._isDragEnabled&&this._getDelta(e)>t._PRESSHOLDMARGIN},t.prototype._shouldStartDragging=function(e){var i=this._getDelta(e);return i>t._THRESHOLD||t._ISPRESSHOLDMODE&&i>=t._PRESSHOLDTHRESHOLD},t.prototype._reset=function(){this._destroyImage(),this._dragSource=null,this._lastTouch=null,this._lastTarget=null,this._ptDown=null,this._isDragEnabled=!1,this._isDropZone=!1,this._dataTransfer=new e,clearInterval(this._pressHoldInterval)},t.prototype._getPoint=function(t,e){return t&&t.touches&&(t=t.touches[0]),{x:e?t.pageX:t.clientX,y:e?t.pageY:t.clientY}},t.prototype._getDelta=function(e){if(t._ISPRESSHOLDMODE&&!this._ptDown)return 0;var i=this._getPoint(e);return Math.abs(i.x-this._ptDown.x)+Math.abs(i.y-this._ptDown.y)},t.prototype._getTarget=function(t){for(var e=this._getPoint(t),i=document.elementFromPoint(e.x,e.y);i&&"none"==getComputedStyle(i).pointerEvents;)i=i.parentElement;return i},t.prototype._createImage=function(e){this._img&&this._destroyImage();var i=this._imgCustom||this._dragSource;if(this._img=i.cloneNode(!0),this._copyStyle(i,this._img),this._img.style.top=this._img.style.left="-9999px",!this._imgCustom){var n=i.getBoundingClientRect(),s=this._getPoint(e);this._imgOffset={x:s.x-n.left,y:s.y-n.top},this._img.style.opacity=t._OPACITY.toString()}this._moveImage(e),document.body.appendChild(this._img)},t.prototype._destroyImage=function(){this._img&&this._img.parentElement&&this._img.parentElement.removeChild(this._img),this._img=null,this._imgCustom=null},t.prototype._moveImage=function(t){var e=this;requestAnimationFrame(function(){if(e._img){var i=e._getPoint(t,!0),n=e._img.style;n.position="absolute",n.pointerEvents="none",n.zIndex="999999",n.left=Math.round(i.x-e._imgOffset.x)+"px",n.top=Math.round(i.y-e._imgOffset.y)+"px"}})},t.prototype._copyProps=function(t,e,i){for(var n=0;n<i.length;n++){var s=i[n];t[s]=e[s]}},t.prototype._copyStyle=function(e,i){if(t._rmvAtts.forEach(function(t){i.removeAttribute(t)}),e instanceof HTMLCanvasElement){var n=e,s=i;s.width=n.width,s.height=n.height,s.getContext("2d").drawImage(n,0,0)}for(var o=getComputedStyle(e),r=0;r<o.length;r++){var a=o[r];a.indexOf("transition")<0&&(i.style[a]=o[a])}i.style.pointerEvents="none";for(r=0;r<e.children.length;r++)this._copyStyle(e.children[r],i.children[r])},t.prototype._dispatchEvent=function(e,i,n){if(e&&n){var s=document.createEvent("Event"),o=e.touches?e.touches[0]:e;return s.initEvent(i,!0,!0),s.button=0,s.which=s.buttons=1,this._copyProps(s,e,t._kbdProps),this._copyProps(s,o,t._ptProps),s.dataTransfer=this._dataTransfer,n.dispatchEvent(s),s.defaultPrevented}return!1},t.prototype._closestDraggable=function(t){for(;t;t=t.parentElement)if(t.hasAttribute("draggable")&&t.draggable)return t;return null},t}();i._instance=new i,i._THRESHOLD=5,i._OPACITY=.5,i._DBLCLICK=500,i._CTXMENU=900,i._ISPRESSHOLDMODE=!1,i._PRESSHOLDAWAIT=400,i._PRESSHOLDMARGIN=25,i._PRESSHOLDTHRESHOLD=0,i._rmvAtts="id,class,style,draggable".split(","),i._kbdProps="altKey,ctrlKey,metaKey,shiftKey".split(","),i._ptProps="pageX,pageY,clientX,clientY,screenX,screenY".split(","),t.DragDropTouch=i}(DragDropTouch||(DragDropTouch={}));

    </script>
    <script>/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */
var saveAs=saveAs||function(e){"use strict";if(typeof e==="undefined"||typeof navigator!=="undefined"&&/MSIE [1-9]\./.test(navigator.userAgent)){return}var t=e.document,n=function(){return e.URL||e.webkitURL||e},r=t.createElementNS("http://www.w3.org/1999/xhtml","a"),o="download"in r,a=function(e){var t=new MouseEvent("click");e.dispatchEvent(t)},i=/constructor/i.test(e.HTMLElement)||e.safari,f=/CriOS\/[\d]+/.test(navigator.userAgent),u=function(t){(e.setImmediate||e.setTimeout)(function(){throw t},0)},s="application/octet-stream",d=1e3*40,c=function(e){var t=function(){if(typeof e==="string"){n().revokeObjectURL(e)}else{e.remove()}};setTimeout(t,d)},l=function(e,t,n){t=[].concat(t);var r=t.length;while(r--){var o=e["on"+t[r]];if(typeof o==="function"){try{o.call(e,n||e)}catch(a){u(a)}}}},p=function(e){if(/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e.type)){return new Blob([String.fromCharCode(65279),e],{type:e.type})}return e},v=function(t,u,d){if(!d){t=p(t)}var v=this,w=t.type,m=w===s,y,h=function(){l(v,"writestart progress write writeend".split(" "))},S=function(){if((f||m&&i)&&e.FileReader){var r=new FileReader;r.onloadend=function(){var t=f?r.result:r.result.replace(/^data:[^;]*;/,"data:attachment/file;");var n=e.open(t,"_blank");if(!n)e.location.href=t;t=undefined;v.readyState=v.DONE;h()};r.readAsDataURL(t);v.readyState=v.INIT;return}if(!y){y=n().createObjectURL(t)}if(m){e.location.href=y}else{var o=e.open(y,"_blank");if(!o){e.location.href=y}}v.readyState=v.DONE;h();c(y)};v.readyState=v.INIT;if(o){y=n().createObjectURL(t);setTimeout(function(){r.href=y;r.download=u;a(r);h();c(y);v.readyState=v.DONE});return}S()},w=v.prototype,m=function(e,t,n){return new v(e,t||e.name||"download",n)};if(typeof navigator!=="undefined"&&navigator.msSaveOrOpenBlob){return function(e,t,n){t=t||e.name||"download";if(!n){e=p(e)}return navigator.msSaveOrOpenBlob(e,t)}}w.abort=function(){};w.readyState=w.INIT=0;w.WRITING=1;w.DONE=2;w.error=w.onwritestart=w.onprogress=w.onwrite=w.onabort=w.onerror=w.onwriteend=null;return m}(typeof self!=="undefined"&&self||typeof window!=="undefined"&&window||this.content);if(typeof module!=="undefined"&&module.exports){module.exports.saveAs=saveAs}else if(typeof define!=="undefined"&&define!==null&&define.amd!==null){define("FileSaver.js",function(){return saveAs})}
    </script>
    <script>'use strict';

const cardSpacing = [remToPx(2), remToPx(2)];
const colors = ['black', 'red', 'green', 'blue'];

async function playableHTMLBlob() {
    const doc = document.documentElement.cloneNode(true);
    doc.querySelector("#scene").innerHTML = "";
    doc.querySelectorAll(".screen").forEach(screen => screen.hidden = true);
    return new Blob([doc.outerHTML], {type: "text/html"});
}

function setupClassHooks() {
    document.querySelectorAll('.block-clicks').forEach(element => {
        element.addEventListener('click', event => event.stopPropagation());
    });
    document.querySelectorAll('.click-to-hide').forEach(element => {
        element.addEventListener('click', () => element.hidden = true);
    })
    document.querySelectorAll('.close-parent-screen').forEach(element => {
        const screen = element.closest('.screen');
        element.addEventListener('click', () => screen.hidden = true);
    });
}

function setCardType(type) {
    if (!domino.selectedCard) return;

    domino.selectedCard.type = type;
    refreshTypeSelect();
    domino.refreshAllCardViews();
}

function refreshTypeSelect() {
    if (!domino.selectedCard) return;

    document.querySelectorAll('.type-button').forEach(button => {
        button.classList.remove('selected');
        if (button.classList.contains(domino.selectedCard.type))
            button.classList.add('selected');
    });
}

function computeCardSize(parent) {
    const testCard = cloneTemplateElement('#card-template');
    parent.appendChild(testCard);
    const size = [testCard.clientWidth, testCard.clientHeight];
    parent.removeChild(testCard);
    return size;
}

const setElementJsonData = (element, data) => queryToElement(element).innerHTML = JSON.stringify(data);
const getElementJsonData = (element) => JSON.parse(queryToElement(element).innerHTML);

async function extractDataFromHtmlFile(file) {
    const html = document.createElement('html');
    html.innerHTML = await textFromFile(file);
    return getElementJsonData(html.querySelector('#data'));
}

async function exportProject() {
    setElementJsonData('#data', domino.getData());
    const blob = await playableHTMLBlob();
    saveAs(blob, `domino-test.html`);
}

function addCardViewListeners(domino, view) {
    view.root.addEventListener('click', () => {
        domino.selectCardView(view);
        domino.centerCell(view.cell);
    });
    view.root.addEventListener('dragstart', event => {
        event.dataTransfer.setData('card-origin-cell', JSON.stringify(view.cell));
        event.dataTransfer.setData('text/plain', view.card.text);
        event.dataTransfer.setData('card/move', '');

        const [x, y] = getElementCenter(view.root);
        event.dataTransfer.setDragImage(view.root, x, y);
    });
    view.root.addEventListener('dragover', event => {
        killEvent(event);
        const newCard = event.dataTransfer.types.includes('card/new');
        event.dataTransfer.dropEffect = newCard ? 'none' : 'move'; 
    });
    view.root.addEventListener('drop', event => {
        killEvent(event);
        if (!event.dataTransfer.types.includes('card/move'))
            return;

        const originJson = event.dataTransfer.getData('card-origin-cell');
        const cell = JSON.parse(originJson);
        domino.swapCells(cell, view.cell);
    });
}

function getCoordsFromHash() {
    try {
        const coords = location.hash.slice(1).split(',').map(i => parseInt(i) || 0);
        if (coords.length === 2) return coords;
    } catch(e) {}

    return [0, 0];
}

const dropContentTransformers = [
    ['card/new',      c => 'new card'],
    ['text/html',     c => c],
    ['text/uri-list', c => c.split('\n').filter(uri => !uri.startsWith('#')).map(uri => `<a href="${uri}">link</a>`)],
    ['text/plain',    c => c],
    ['text',          c => c],
];

class Domino {
    constructor() {
        this.cellToView = new CoordStore();
        this.selectedCard = undefined;
    }

    centerCell(coords) {
        const [cx, cy] = getElementCenter(document.documentElement);
        const [nx, ny] = this.grid.cellToPixel(coords);
        const [x, y] = [cx - nx, cy - ny];
        this.scene.style.transform = `translate(${x}px, ${y}px)`;
        location.hash = coordsToKey(coords);
    }

    async centerCellNoTransition(coords) {
        this.scene.classList.add('skiptransition');
        this.centerCell(coords);
        await sleep(10);
        this.scene.classList.remove('skiptransition');
    }

    async spawnCardView(card, cell) {
        const view = this.createCardView(card, cell);
        view.scale = 0;
        await sleep(10);
        view.scale = 1;
        return view;
    }

    createCardView(card, cell) {
        const view = new CardView(cell, card);
    
        addCardViewListeners(this, view);
        this.scene.appendChild(view.root);
        this.moveCardViewToCell(view, cell);
    
        return view;
    }

    removeCardView(view) {
        this.scene.removeChild(view.root);
        this.cellToView.delete(view.cell);
        if (this.selectedCard === view.card)
            this.deselect();
    }

    moveCardViewToCell(view, cell) {
        view.cell = cell;
        view.position = this.grid.cellToPixel(cell);
        this.cellToView.set(cell, view);
    }

    refreshAllCardViews() {
        this.cellToView.store.forEach(view => view.refresh());
    }

    swapCells(a, b) {
        if (coordsAreEqual(a, b))
            return;
        
        const aView = this.cellToView.get(a);
        const bView = this.cellToView.get(b);
    
        this.cellToView.delete(a);
        this.cellToView.delete(b);
    
        if (aView)
            this.moveCardViewToCell(aView, b);
        if (bView)
            this.moveCardViewToCell(bView, a);
    }

    clear() {
        this.deselect();
        this.scene.innerHTML = "";
        this.cellToView.store.clear();
    }

    setData(data) {
        this.clear();
        for (let view of data.views)
            this.createCardView(data.cards[view.card], view.cell);
    }

    getData() {
        const cardData = {};
        const viewData = [];
        const cardToId = new Map();
        const generateID = makeCounter();
    
        function getCardId(card) {
            let id = cardToId.get(card) || generateID();
            cardToId.set(card, id);
            cardData[id] = card;
            return id;
        }
        
        this.cellToView.store.forEach((view) => {
            viewData.push({ cell: view.cell, card: getCardId(view.card) });
        });
    
        return {
            editable: false,
            cards: cardData,
            views: viewData, 
        };
    }

    setup() {
        this.scene = document.querySelector('#scene');
        const [cw, ch] = computeCardSize(this.scene);
        const [sw, sh] = cardSpacing;
        this.grid = new HexGrid([cw + sw, ch + sh]);

        // hide fullscreen button if fullscreen is not possible
        document.querySelector('#fullscreen').hidden = !document.fullscreenEnabled;

        this.cardbar = cloneTemplateElement('#cardbar-template');
        this.cardbar.id = 'cardbar';
        const editCard = this.cardbar.querySelector('#edit-card');

        const importFile = document.querySelector('#import-file');
        const screen = document.querySelector('#screen');
        this.addDeleteCardIcon = document.querySelector('#add-delete-icon');
        this.enableEdit = document.querySelector('#enable-edit')

        this.aboutScreen = document.querySelector('#about-screen');

        this.editorPanel = document.querySelector('#editor-panel');
        this.contentInput = this.editorPanel.querySelector('#content-input');

        addListener(this.editorPanel, 'drop', killEvent);
        setElementDragoverDropEffect(this.editorPanel, 'none');

        addListener(editCard,       'click', () => this.editorPanel.hidden = false);
        addListener('#center',      'click', () => location.hash = '0,0');
        addListener('#open-about',  'click', () => this.aboutScreen.hidden = false);
        addListener('#enable-edit', 'click', () => this.setEditable(true));
        addListener('#reset',       'click', () => this.clear());
        addListener('#import',      'click', () => importFile.click());
        addListener('#export',      'click', () => exportProject());
        addListener('#fullscreen',  'click', () => toggleFullscreen());

        const jumpFromHash = () => this.centerCell(getCoordsFromHash());
        window.addEventListener('hashchange', jumpFromHash);
        window.addEventListener('resize', jumpFromHash);

        addListener(importFile, 'change', async event => {
            this.setData(await extractDataFromHtmlFile(event.target.files[0]));
        });

        this.contentInput.addEventListener('input', () => {
            if (!this.selectedCard) return;
            this.selectedCard.text = this.contentInput.value;
            this.refreshAllCardViews();
        });

        addListener(this.addDeleteCardIcon, 'dragstart', event => {
            event.dataTransfer.setData('card/new', '');
        });
    
        setElementDragoverDropEffect(this.addDeleteCardIcon, 'move');
    
        addListener(this.addDeleteCardIcon, 'drop', event => {
            killEvent(event);
            if (event.dataTransfer.types.includes('card/move')) {
                const originJson = event.dataTransfer.getData('card-origin-cell');
                const view = this.cellToView.get(JSON.parse(originJson));
                this.removeCardView(view);
            }
        });

        setElementDragoverDropEffect(screen, 'copy');
        addListener(screen, 'click', event => {
            killEvent(event);
            const clickPixel = eventToElementPixel(event, this.scene);
            const clickCell = this.grid.pixelToCell(clickPixel);
            this.centerCell(clickCell);
            this.deselect();
        });
        addListener(screen, 'drop', async event => {
            killEvent(event);
            const dropPixel = eventToElementPixel(event, this.scene);
            const dropCell = this.grid.pixelToCell(dropPixel);
            
            const amMovingCard = event.dataTransfer.types.includes('card/move');
            const cellIsEmpty = !this.cellToView.has(dropCell);
    
            if (amMovingCard) {
                const originJson = event.dataTransfer.getData('card-origin-cell');
                const originCell = JSON.parse(originJson);
    
                this.swapCells(originCell, dropCell);
            } else if (cellIsEmpty) {
                let content = undefined;
    
                for (let [field, transformer] of dropContentTransformers) {
                    if (event.dataTransfer.types.includes(field)) {
                        const data = event.dataTransfer.getData(field);
                        content = transformer(data);
                        break;
                    }
                }
    
                if (content) {
                    const card = { text: content, type: 'black' };
                    const view = await this.spawnCardView(card, dropCell);
                    this.selectCardView(view);
                }
            }
        });
    }

    setEditable(editable) {
        this.editable = editable;
        this.enableEdit.disabled = editable;
        this.addDeleteCardIcon.hidden = !editable;
    }
    
    deselect() { this.selectCardView(undefined); }

    selectCardView(view) {
        this.selectedCard = view ? view.card : undefined;
        this.cardbar.hidden = (view === undefined) || !this.editable;

        if (view) {
            this.contentInput.value = view.card.text;
            view.root.appendChild(this.cardbar);
        }

        refreshTypeSelect();
        this.refreshAllCardViews();
    }
}

class CardView {
    constructor(cell, card) {
        this._position = [0, 0];
        this._scale = 1;
        this.cell = cell;
        this.card = card;

        this.root = cloneTemplateElement('#card-template');
        this.text = this.root.querySelector('.card-text');
        this.icons = this.root.querySelector('.icon-bar');
        
        this.refresh();
    }

    set position(value) { 
        this._position = value;
        this.updateTransform();
    }

    set scale(value) { 
        this._scale = value;
        this.updateTransform();
    }

    updateTransform() {
        const [x, y] = this._position;
        const position = `translate(calc(${x}px - 50%), calc(${y}px - 50%))`;
        const scaling = `scale(${this._scale}, ${this._scale})`;
        this.root.style.transform = `${position} ${scaling}`;
    }

    refresh() {
        this.root.classList.remove(...colors);
        this.root.classList.add(this.card.type);
        this.text.innerHTML = this.card.text;
    }
}

const domino = new Domino();

async function loaded() {
    setupClassHooks();

    domino.setup();

    // load data from embeded #data script tag
    const data = getElementJsonData('#data');
    domino.setEditable(data.editable);
    domino.setData(data);
    domino.centerCellNoTransition(getCoordsFromHash());
}

    </script>
  </head>
  <body onload="loaded()">
    <div id="templates" hidden>
      <div class="card" id="card-template" draggable="true">
        <div class="card-text"></div>
        <div class="icon-bar"></div>
      </div>
      <div class="icon-bar" id="cardbar-template" hidden>
        <button id="edit-card" title="edit this card">üìù</button>
        <!--button üîó-->
        <!--button üåç-->
        <!--button üìñ-->
        <!--button H-->
      </div>
    </div>
    <div class="no-select" id="screen"></div>
    <main id="scene"></main>
    <div class="icon-bar" id="toolbar">
      <button id="open-about" title="information about this tool">‚ùî</button>
      <button id="center" title="jump to center">üß≠</button>
      <button id="add-delete-icon" hidden draggable="true" title="drag a new card from here or a drop an unwanted card">üóÉÔ∏è</button>
      <button id="fullscreen" title="toggle fullscreen">üí¢</button>
    </div>
    <div class="block-clicks" id="editor-panel" hidden>
      <button onclick="document.querySelector('#editor-panel').hidden = true;" style="float: right">close</button>
      <h3>edit card</h3>
      <div id="type-select">
        <div class="type-button black" onclick="setCardType('black')"></div>
        <div class="type-button red" onclick="setCardType('red')"></div>
        <div class="type-button green" onclick="setCardType('green')"></div>
        <div class="type-button blue" onclick="setCardType('blue')"></div>
      </div>
      <textarea id="content-input"></textarea>
    </div>
    <div class="screen click-to-hide" id="about-screen" hidden>
      <div class="full-panel block-clicks">
        <button class="close-parent-screen">exit window</button>
        <div id="version">
          version‚Äîalpha (2020-3-4)</div>
        <div id="project-menu">
          <button id="enable-edit" title="enable editing">üìù enable editing</button>
          <button id="import" title="import a domino project">üìÇ import from html</button>
          <button id="export" title="export as html">üì¶ export to html</button>
          <button id="reset" title="remove all cards">‚ùå remove all cards</button>
        </div>
        <input id="import-file" type="file" accept=".html" hidden><h1>domino</h1>
<h2>about</h2>
<p>domino is a tool for collaging fragmented thoughts into a larger idea.
it's essentially a tool for making a particular kind of mindmap and sharing it
as a page on your website or itch.io.</p>
<p>domino is a <a href="https://candle.neocities.org/2020/02/26/speculations.html">response to my frustration</a> trying to express myself in Emilie
Reed's writing jams.</p>
<h2>credits &amp; thanks</h2>
<h3>creators</h3>
<ul>
<li>mark wonnacott</li>
</ul>
<h3>inspiration</h3>
<ul>
<li>Em Reed‚Äî<a href="https://itch.io/jam/manifesto-jam">Manifesto Jam</a>, <a href="https://itch.io/jam/speculation-jam">Speculation Jam</a></li>
<li>Max‚Äî<a href="https://github.com/synth-ruiner/image-to-bitsy">image to bitsy</a></li>
<li>sg‚Äî<a href="https://zenzoa.itch.io/mosi">m√¥si</a></li>
<li>Kris De Decker‚Äî<a href="https://solar.lowtechmagazine.com/">LOW‚ÜêTECH MAGAZINE</a></li>
<li>Chris Klimas‚Äî<a href="https://twinery.org/">Twine</a></li>
</ul>
<h3>libraries</h3>
<ul>
<li>Bernardo Castilho‚Äî<a href="https://github.com/Bernardo-Castilho/dragdroptouch">DragDropTouch</a></li>
<li>Eli Grey‚Äî<a href="https://github.com/eligrey/FileSaver.js/">FileSaver.js</a></li>
<li>Cyreal‚Äî<a href="https://fonts.google.com/specimen/Lora">Lora font</a></li>
</ul>

      </div>
    </div>
  </body>
</html>