<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="twitter:card" value="summary">
    <meta name="twitter:title" value="domino: a tool for collaging thoughts">
    <meta name="twitter:image" value="https://kool.tools/domino/twitter-card.png">
    <meta name="twitter:image:alt" value="low fidelity image of many dominoes connected">
    <title>domino</title>
    <script id="data" type="text/json">{"cards":[{"text":"##domino##a tool for collaging thoughts","type":"heading","cell":[0,0]},{"text":"domino is attempting to be a tool i can use to collage thought fragments in a presentable way","type":"basic-red","cell":[0,-2]},{"text":"##motivation##read on to find out what domino is trying to do and why it was created","type":"heading","cell":[0,-1]},{"text":"##technical details##read on for information about how domino is made","type":"heading","cell":[-1,0],"icons":[{"icon":"","command":""},{"icon":"","command":""},{"icon":"","command":""},{"icon":"","command":""}]},{"text":"##how to use##read on for details of how to make your own boards","type":"heading","cell":[1,-1]},{"text":"##roadmap## read on to find out planned features for domino","type":"heading","cell":[1,0],"icons":[{"icon":"üîé","command":"#3,2"},{"icon":"","command":""},{"icon":"","command":""},{"icon":"","command":""}]},{"text":"##moving cards##i probably need to add some more powerful tools for moving cards around","type":"heading","cell":[3,2],"icons":[{"icon":"üîô","command":"#1,0"},{"icon":"","command":""},{"icon":"","command":""},{"icon":"","command":""}]},{"text":"you can only move one card at once, and you can only move it to somewhere you can see","type":"basic-red","cell":[3,3]},{"text":"what if you could drop cards into am intermediate holding area then drag them back out where you want them?","type":"basic-red","cell":[4,2]},{"text":"i'm using pug to generate the html so i can edit the scripts/style/etc separately rather than in one long html file","type":"basic-green","cell":[-2,1]},{"text":"usually i make my tools in typescript via create-react-app (without react)--doing it raw (and now via pug) has been surprisingly easy","type":"basic-green","cell":[-2,2]},{"text":"everything is a single standalone html file that makes a copy of itself when you export a project","type":"basic-green","cell":[-2,0]},{"text":"for ease of distribution, i think it's essential that tools export to a single standalone html file (when possible)","type":"basic-red","cell":[-1,-1]},{"text":"this page is both an exported domino project and the domino editor","type":"basic-green","cell":[-3,0]},{"text":"you can customise the styling of the board by editing the css of your export","type":"basic-green","cell":[-3,1]},{"text":"i like the idea that just by distributing an export you're also distributing the tool for someone to create their own","type":"basic-red","cell":[-3,-1]},{"text":"##blog post##a self-replicating and mutating tool?","type":"heading","icons":[{"icon":"üß¨","command":"https://kool.tools/domino/digital-organism.html"},{"icon":"","command":""},{"icon":"","command":""},{"icon":"üè†","command":"#0,0"}],"cell":[-4,0]},{"text":"that exported board is now an editor that makes boards in your customised style","type":"basic-green","cell":[-4,1]},{"text":"i need to clean up the html/css/javascript now things are solidifying--want it to be robust straight forward to modify","type":"basic-red","cell":[-4,2]},{"text":"should an exported board default to edit mode?","type":"basic-red","cell":[-2,-2]},{"text":"\"domino\" because putting thoughts with something in common adjacent to each other reminded me of matching dominoes","type":"basic-red","cell":[0,-3]},{"text":"##blog post##read more about the inspiration and goals of domino on my blog","type":"heading","icons":[{"icon":"üîó","command":"https://candle.neocities.org/2020/02/26/speculations.html"},{"icon":"","command":""},{"icon":"","command":""},{"icon":"üè†","command":"#0,0"}],"cell":[0,-4]},{"text":"click on a card to jump to it\n\nclick and drag the background to move around freely","type":"basic-blue","cell":[2,-2]},{"text":"domino is a board of hand-placed cards","type":"basic-green","cell":[2,-3]},{"text":"it's supposed to be kinda like a mind map, but with all links implied by proximity","type":"basic-red","cell":[1,-3]},{"text":"click the home icon üè† to return to the center of the board","type":"basic-blue","cell":[3,-2]},{"text":"##navigating##moving around and reading a domino board","type":"heading","cell":[3,-3]},{"text":"##editing##creating or remixing a domino board","type":"heading","cell":[5,-4]},{"text":"if the toolbar at the bottom of the screen shows üîí, the board is locked to prevent accidental editing. click it to üîì to allow editing","type":"basic-blue","cell":[4,-3]},{"text":"`‚†Ä‚†Ä ‚†Ä  ü§†      howdy. im\n„ÄÄ  ü§†ü§†ü§†   the sheriff\n   ü§† ü§† ü§†   of cowboy\n  üëá  ü§†ü§† üëá  hat face\n     ü§†„ÄÄü§†\n„ÄÄ  ü§†„ÄÄ ü§†","type":"basic-red","icons":[{"icon":"üë¢","command":"display:https://www.youtube.com/embed/zzICMIu5zFY?autoplay=1"},{"icon":"üë¢","command":"display:https://www.youtube.com/embed/1vrEljMfXYo?autoplay=1"},{"icon":"","command":""},{"icon":"üêç","command":"#4,-5"}],"cell":[3,-7]},{"text":"click and drag to move cards around the board (moving to free spaces or swapping with an existing card)","type":"basic-blue","cell":[6,-4]},{"text":"card icons are a way to add hyperlinks (and later, more) to cards. each card has room for four emoji links","type":"basic-green","icons":[{"icon":"üåû","command":"https://solar.lowtechmagazine.com/"},{"icon":"ü¶Ä","command":"https://emmadaues.neocities.org/"},{"icon":"üè∞","command":"https://spdrcstl.com/"},{"icon":"üêû","command":"https://emreed.net/"}],"cell":[3,-4]},{"text":"click on a card and then the writing icon üìù to edit that card","type":"basic-blue","cell":[5,-5]},{"text":"click the info icon ‚ùî to open the menu","type":"basic-blue","cell":[5,-3]},{"text":"you can hyperlink to another card by using the coordinates like #3,-7 (check the url bar)","type":"basic-green","icons":[{"icon":"ü§†","command":"#3,-7"},{"icon":"","command":""},{"icon":"","command":""},{"icon":"","command":""}],"cell":[4,-5]},{"text":"click and drag the cards icon (üóÉ) onto an empty cell to create a new card","type":"basic-blue","cell":[6,-5]},{"text":"##menu##click ‚ùî on the toolbar to open the global menu","type":"heading","cell":[7,-6]},{"text":"you can click \"‚ùå remove all cards\" to completely clear the board--be careful, there is no undo!","type":"basic-green","cell":[8,-7]},{"text":"click \"üì¶ export to html\" to save the board to html","type":"basic-blue","cell":[7,-7]},{"text":"a domino board exported to html can be uploaded as a viewable webpage, imported into domino to edit, or used to edit itself","type":"basic-green","icons":[{"icon":"üé¥","command":"#-3,-1"},{"icon":"","command":""},{"icon":"","command":""},{"icon":"","command":""}],"cell":[7,-8]},{"text":"drag a card onto cards icon (üóÉ) to remove it","type":"basic-blue","cell":[6,-6]},{"text":"there is some support for styling e.g **bold** and *italics*. you can also ~~strikethrough~~ text and make ##headings##","type":"basic-red","cell":[5,-6]},{"text":"`there is some support for \nstyling e.g **bold** and \n*italics*. you can also \n~~strikethrough~~ text and \nmake ##headings##","type":"basic-red","cell":[5,-7]},{"text":"you can also make your own styling changes by editing the css of the exported html file","type":"basic-red","cell":[6,-7],"icons":[{"icon":"üë©‚Äçüíª","command":"#-3,1"},{"icon":"","command":""},{"icon":"","command":""},{"icon":"","command":""}]},{"text":"click \"üìÇ import from html\" to load domino board for editing","type":"basic-blue","cell":[8,-6]},{"text":"if you have and feedback, especially bug reports, please do contact me","type":"basic-red","cell":[0,2]},{"text":"i have no access to macOS or iOS so reports, particularly about bugs on safari, are appreciated","type":"basic-red","cell":[-1,3]},{"text":"##extra structure##thinking about extra structure beyond layout cards on a grid","type":"heading","cell":[3,1]},{"text":"sometimes you really do want to write a linear block of text--what if cards could contain a larger post that can be expanded?","type":"basic-red","cell":[4,0]},{"text":"##saving##exporting a copy every time you want to save is kinda annoying","type":"heading","cell":[2,1]},{"text":"##mobile support##mobile technically works, but the user experience isn't great","type":"heading","cell":[2,2],"icons":[{"icon":"","command":""},{"icon":"","command":""},{"icon":"","command":""},{"icon":"","command":""}]},{"text":"##contact##you can contact me on twitter (@ragzouken)","type":"heading","icons":[{"icon":"üê¶","command":"http://twitter.com/ragzouken"},{"icon":"","command":""},{"icon":"","command":""},{"icon":"","command":""}],"cell":[0,1]},{"text":"##source code##the source code and build scripts for domino are available on github","type":"heading","icons":[{"icon":"üîó","command":"https://github.com/Ragzouken/domino"},{"icon":"","command":""},{"icon":"","command":""},{"icon":"","command":""}],"cell":[-1,1]},{"text":"closing the editor doesn't seem to work in firefox mobile, but i don't have any way to debug this--help?","type":"basic-red","cell":[1,3]},{"text":"you can't see enough cards at once on mobile--maybe pinch zoom would work for this?","type":"basic-red","cell":[1,4]},{"text":"##navigating##moving through larger boards","type":"heading","cell":[2,4]},{"text":"now that you can add larger text to cards by way of headings, it probably makes sense to add zooming out to see a higher level picture","type":"basic-red","cell":[1,5]},{"text":"privacy browser extensions break many image hotlinks, and many pages prevent iframe embedding--as a fallback i open a new tab","type":"basic-red","cell":[6,-1]},{"text":"`experimenting with an\niframe/image feature\n\nin icons:\ndisplay:http://bla.com\nimage:http://bla.com/a.png","type":"heading","cell":[5,-1],"icons":[{"icon":"üë∫","command":"display:https://www.youtube.com/embed/2GjyNgQ4Dos?autoplay=1"},{"icon":"üë∂","command":"image:https://www.indiewire.com/wp-content/uploads/2019/11/960x0-2.jpg?w=780"},{"icon":"","command":""},{"icon":"","command":""}]}]}</script>
    <link href="https://fonts.googleapis.com/css?family=Lora&display=swap" rel="stylesheet">
    <style>:root {
    --editor-background: rgb(240, 248, 255);

    touch-action: none;
}

.card h3 {
    display: block; 
    font-size: 1.5em; 
    font-weight: bold;
    text-align: center;

    margin: 0;
    margin-bottom: .5em;
}

#coords {
    position: absolute;
    left: 0;
    top: 0;

    font-family: monospace;
    margin: .25em;
    padding: .25em .5em;
    border-radius: .75em;

    color: var(--background-text-color);
    background: var(--background-color);
}

#display-image {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
}

#display-frame {
    background: white;

    margin: 0;
    padding: 0;
    border: none;

    max-width: 100%;
    max-height: 100%;

    width: 800px;
    height: 600px;

    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
}

#display-screen > .full-panel {
    padding: 0;
    overflow: hidden;
}

/* hidden elements should be hidden regardless of their display style */
[hidden] { 
    display: none !important; 
}

.skiptransition {
    transition: none !important;
}

.no-select {
    -webkit-tap-highlight-color: transparent;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}

html, body {
    position: absolute;
    overflow: hidden;
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
}

html {
    width: 100vw;
    height: calc(var(--vh, 1vh) * 100);
}

html {
    background: var(--background-color);

    font-family: lora;
    font-size: 1.1em;
}

button, textarea {
    font-family: lora;
    font-size: 1em;
}

#screen {
    width: 100%;
    height: 100%;

    position: absolute;
    margin: 0;
    padding: 0;

    cursor: pointer;
}

main {
    transition: transform .2s ease-in-out;
    width: 0;
    height: 0;
}

.screen {
    background-color: rgb(0, 0, 0, .25);
    
    pointer-events: auto;
    cursor: pointer;
    
    position: absolute;
    box-sizing: border-box;
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
}

.full-panel {
    cursor: auto;
    box-sizing: border-box;

    margin: auto;

    padding: 2em;

    width: 40em;
    height: 100%;
    max-width: 100%;

    background-color: var(--background-color);

    overflow: auto;
}

#editor-panel {
    width: calc(var(--card-width));
    position: absolute;
    padding: 1em;
    
    background: var(--editor-background);
    pointer-events: initial;

    left: 50%;
    transform: translateX(-50%);
    bottom: 0;
    margin: 0;

    max-width: 100%;
}

#editor-panel > h3 {
    margin-top: 0;
}

#content-input {
    padding: 1em;
    flex: 1;
    border: none;
    border-bottom: 2px solid black;
}

#type-select {
    height: 2em;
    margin-bottom: 1em;
    display: grid;
    column-gap: .5em;
}

#type-select > * {
    height: 100%;
    grid-row: 1;
    border-bottom: 1px solid black;
    cursor: pointer;
}

#type-select > *:hover {
    height: calc(100% + .5em);
}

#type-select > *.selected {
    height: calc(100% + .5em);
}

.card {
    box-sizing: content-box;
    position: absolute;
    cursor: pointer;

    transition: transform .2s ease-in-out;

    width: var(--card-width);
    height: var(--card-height);

    display: flex;
    margin: 0 0 1em;
    word-wrap: break-word;
}

.card-text {
    box-sizing: border-box;
    width: 100%;
    padding: 1em;
}

#version {
    float: right;
}

.icon-bar {
    cursor: unset;
    position: absolute;

    font-size: 1.5rem;

    display: grid;
    column-gap: .5em;
    margin: 0;
}

.icon-bar > button, .icon-bar > a {
    width: 2em;
    height: 2em;
    grid-row: 1;

    padding: 0;
    
    display: flex;
    align-items: center;
    justify-content: center;
    text-decoration: none;
}

.card-icon-bar {
    font-size: 1rem;

    left: 50%;
    transform: translate(-50%, 50%);
    bottom: 0;

    column-gap: .75em;
}

.card-edit-bar {
    font-size: 1.25em;

    top: 50%;
    transform: translate(50%, -50%);
    right: 0;
}

.card-icon-bar > a {
    cursor: pointer;
    border: none;
    background: none;

    transition: transform .1s ease-in-out;
}

.card-icon-bar > a:hover {
    transform: scale(1.5);
}
.card-icon-bar > a:active {
    transform: scale(2);
}

.card-icon-bar > a.cosmetic {
    cursor: initial;
    transform: unset;
}

.card-icon-bar > a.blank {
    pointer-events: none;
    transform: unset;
}

#toolbar {
    left: 50%;
    transform: translate(-50%, 0);
    bottom: 0;
    
    margin-bottom: .5em;
}

#project-menu {
    margin-top: 1em;
    display: grid;
    column-gap: 1em;
}

#project-menu > button {
    grid-row: 1;
}

#editor-preview {
    width: 100%;
    height: calc(var(--card-height) * 2);
    min-height: calc(100% - var(--card-height) * 2);
}

#editor-section {
    background: var(--editor-background);
    pointer-events: initial;
    cursor: initial;

    position: absolute;
    width: calc(var(--card-width) + 4em);
    max-width: 100%;
    height: calc(100% - var(--card-height) * 2);
    max-height: calc(var(--card-height) * 2);

    left: 50%;
    bottom: 0;
    transform: translateX(-50%);

    box-sizing: border-box;
    
    display: flex;
    flex-direction: column;
}

#editor-tabs {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    color: white;
    background:black;
}

#editor-tabs > div {
    padding: 1em;
    border: initial;

    text-align: center;
}

#editor-tabs > div.selected {
    border: none;
    color: black;
    background: var(--editor-background);
}

.editor-page {
    flex: 1;

    display: flex;
    flex-direction: column;
    padding: 1em;
}

#editor-page-icons {
    display: grid;

    grid-template-columns: repeat(4, 1fr);
    grid-template-rows: repeat(4, 1fr);

    column-gap: 1em;
    row-gap: 1em;
}

#editor-page-icons > input {
    border: none;
    border-left: 2px solid black;
    padding: .5em;
}

.icon-select {
    min-width: 0;
    text-align: center;
    font-size: 1em;

    grid-column-start: 1;
    grid-column-end: 2;
}

.icon-command {
    font-size: 1em;
    font-family: monospace;

    grid-column-start: 2;
    grid-column-end: 5;
}

    </style>
    <style id="user-style">:root {
    --background-color: rgb(255, 245, 209);
    --background-text-color: black;

    --card-width: 15rem;
    --card-height: calc(var(--card-width) * .6);
}

/* base style for cards */
.card {
    background: white;
    color: black;

    /*border: 1px dashed black;*/
    border-radius: .5em;
    border-bottom: 3px solid black;
}

.card-text {
    overflow: hidden;
}

/* custom card styles */
.domino-card-heading { 
    background: #F3E9C7;
    align-items: center;
}

.domino-card-basic-red   { background: #FDE9C6; }
.domino-card-basic-green { background: #F0EDC5; }
.domino-card-basic-blue  { background: #F2EED2; }

    </style>
    <script>const ONE = (query, element) => (element || document).querySelector(query);
const ALL = (query, element) => (element || document).querySelectorAll(query);

const makeCounter = (count=0) => () => count++;
const remToPx = em => emToPx(document.documentElement, em);
const emToPx = (element, em) => Math.round(em * parseFloat(getComputedStyle(element).fontSize));
const setElementJsonData = (element, data) => queryToElement(element).innerHTML = JSON.stringify(data);
const getElementJsonData = (element) => JSON.parse(queryToElement(element).innerHTML);
const reflow = element => void(element.offsetHeight);

function toggleFullscreen() {
    if (document.fullscreenElement) {
        return document.exitFullscreen();
    } else {
        return document.documentElement.requestFullscreen({ navigationUI: 'hide' });
    }
}

async function textFromFile(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onerror = reject;
        reader.onload = () => resolve(reader.result);
        reader.readAsText(file); 
    });
}

async function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function killEvent(event) {
    event.stopPropagation();
    event.preventDefault();
}

function eventToElementPixel(event, element) {
    const rect = element.getBoundingClientRect();
    return [event.clientX - rect.x, event.clientY - rect.y];
}

function getElementCenter(element) {
    return [element.clientWidth / 2, element.clientHeight / 2];
}

function getElementCenterClient(element) {
    const rect = element.getBoundingClientRect();
    return [rect.x + rect.width / 2, rect.y + rect.height / 2];
}

function setElementDragoverDropEffect(query, effect) {
    addListener(query, 'dragover', event => {
        killEvent(event);
        event.dataTransfer.dropEffect = effect;
    });
}

function queryToElement(query) {
    return (query instanceof Element) ? query : ONE(query);
}

function cloneTemplateElement(query) {
    const template = queryToElement(query);
    const clone = template.cloneNode(true);
    clone.removeAttribute('id');
    return clone;
}

function addListener(query, type, listener) {
    queryToElement(query).addEventListener(type, listener);
}

function coordsToKey(coords) {
    return coords.join(',');
}

class CoordStore {
    constructor() { this.store = new Map(); }
    get size() { return this.store.size; }
    get(coords) { return this.store.get(coordsToKey(coords)); }
    set(coords, value) { return this.store.set(coordsToKey(coords), value); }
    delete(coords) { return this.store.delete(coordsToKey(coords)); }
    has(coords) { return this.store.has(coordsToKey(coords)); }
}

// based on https://www.redblobgames.com/grids/hexagons/
class HexGrid {
    constructor(cellSize) {
        this.cellSize = cellSize;
    }

    cellToPixel(cellCoords) {
        const [q, r] = cellCoords;
        const [w, h] = this.cellSize;

        const x = q * w;
        const y = (r + q / 2) * h;
        return [x, y];
    }

    pixelToCell(pixelCoords) {
        const [x, y] = pixelCoords;
        const [w, h] = this.cellSize;
        // pixel to axial coordinates
        const q = x / w;
        const r = y / h - q / 2;
        // convert axial to cube coordinates
        const [cx, cy, cz] = [q, r, -q-r];
        // determine rounding error
        let [rx, ry, rz] = [cx, cy, cz].map(Math.round);
        const [dx, dy, dz] = [rx - cx, ry - cy, rz - cz].map(Math.abs);
        // recompute worst coordinate from others
        if (dx > dy && dx > dz) {
            rx = -ry-rz
        } else if (dy > dz) {
            ry = -rx-rz
        } else {
            rz = -rx-ry
        }
        // return axial components
        return [rx, ry];
    }
}

    </script>
    <script>var DragDropTouch;!function(t){"use strict";var e=function(){function t(){this._dropEffect="move",this._effectAllowed="all",this._data={}}return Object.defineProperty(t.prototype,"dropEffect",{get:function(){return this._dropEffect},set:function(t){this._dropEffect=t},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"effectAllowed",{get:function(){return this._effectAllowed},set:function(t){this._effectAllowed=t},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"types",{get:function(){return Object.keys(this._data)},enumerable:!0,configurable:!0}),t.prototype.clearData=function(t){null!=t?delete this._data[t]:this._data=null},t.prototype.getData=function(t){return this._data[t]||""},t.prototype.setData=function(t,e){this._data[t]=e},t.prototype.setDragImage=function(t,e,n){var s=i._instance;s._imgCustom=t,s._imgOffset={x:e,y:n}},t}();t.DataTransfer=e;var i=function(){function t(){if(this._lastClick=0,t._instance)throw"DragDropTouch instance already created.";var e=!1;if(document.addEventListener("test",function(){},{get passive(){return e=!0,!0}}),"ontouchstart"in document){var i=document,n=this._touchstart.bind(this),s=this._touchmove.bind(this),o=this._touchend.bind(this),r=!!e&&{passive:!1,capture:!1};i.addEventListener("touchstart",n,r),i.addEventListener("touchmove",s,r),i.addEventListener("touchend",o),i.addEventListener("touchcancel",o)}}return t.getInstance=function(){return t._instance},t.prototype._touchstart=function(e){var i=this;if(this._shouldHandle(e)){if(Date.now()-this._lastClick<t._DBLCLICK&&this._dispatchEvent(e,"dblclick",e.target))return e.preventDefault(),void this._reset();this._reset();var n=this._closestDraggable(e.target);n&&(this._dispatchEvent(e,"mousemove",e.target)||this._dispatchEvent(e,"mousedown",e.target)||(this._dragSource=n,this._ptDown=this._getPoint(e),this._lastTouch=e,e.preventDefault(),setTimeout(function(){i._dragSource==n&&null==i._img&&i._dispatchEvent(e,"contextmenu",n)&&i._reset()},t._CTXMENU),t._ISPRESSHOLDMODE&&(this._pressHoldInterval=setTimeout(function(){i._isDragEnabled=!0,i._touchmove(e)},t._PRESSHOLDAWAIT))))}},t.prototype._touchmove=function(t){if(this._shouldCancelPressHoldMove(t))this._reset();else if(this._shouldHandleMove(t)||this._shouldHandlePressHoldMove(t)){var e=this._getTarget(t);if(this._dispatchEvent(t,"mousemove",e))return this._lastTouch=t,void t.preventDefault();this._dragSource&&!this._img&&this._shouldStartDragging(t)&&(this._dispatchEvent(t,"dragstart",this._dragSource),this._createImage(t),this._dispatchEvent(t,"dragenter",e)),this._img&&(this._lastTouch=t,t.preventDefault(),e!=this._lastTarget&&(this._dispatchEvent(this._lastTouch,"dragleave",this._lastTarget),this._dispatchEvent(t,"dragenter",e),this._lastTarget=e),this._moveImage(t),this._isDropZone=this._dispatchEvent(t,"dragover",e))}},t.prototype._touchend=function(t){if(this._shouldHandle(t)){if(this._dispatchEvent(this._lastTouch,"mouseup",t.target))return void t.preventDefault();this._img||(this._dragSource=null,this._dispatchEvent(this._lastTouch,"click",t.target),this._lastClick=Date.now()),this._destroyImage(),this._dragSource&&(t.type.indexOf("cancel")<0&&this._isDropZone&&this._dispatchEvent(this._lastTouch,"drop",this._lastTarget),this._dispatchEvent(this._lastTouch,"dragend",this._dragSource),this._reset())}},t.prototype._shouldHandle=function(t){return t&&!t.defaultPrevented&&t.touches&&t.touches.length<2},t.prototype._shouldHandleMove=function(e){return!t._ISPRESSHOLDMODE&&this._shouldHandle(e)},t.prototype._shouldHandlePressHoldMove=function(e){return t._ISPRESSHOLDMODE&&this._isDragEnabled&&e&&e.touches&&e.touches.length},t.prototype._shouldCancelPressHoldMove=function(e){return t._ISPRESSHOLDMODE&&!this._isDragEnabled&&this._getDelta(e)>t._PRESSHOLDMARGIN},t.prototype._shouldStartDragging=function(e){var i=this._getDelta(e);return i>t._THRESHOLD||t._ISPRESSHOLDMODE&&i>=t._PRESSHOLDTHRESHOLD},t.prototype._reset=function(){this._destroyImage(),this._dragSource=null,this._lastTouch=null,this._lastTarget=null,this._ptDown=null,this._isDragEnabled=!1,this._isDropZone=!1,this._dataTransfer=new e,clearInterval(this._pressHoldInterval)},t.prototype._getPoint=function(t,e){return t&&t.touches&&(t=t.touches[0]),{x:e?t.pageX:t.clientX,y:e?t.pageY:t.clientY}},t.prototype._getDelta=function(e){if(t._ISPRESSHOLDMODE&&!this._ptDown)return 0;var i=this._getPoint(e);return Math.abs(i.x-this._ptDown.x)+Math.abs(i.y-this._ptDown.y)},t.prototype._getTarget=function(t){for(var e=this._getPoint(t),i=document.elementFromPoint(e.x,e.y);i&&"none"==getComputedStyle(i).pointerEvents;)i=i.parentElement;return i},t.prototype._createImage=function(e){this._img&&this._destroyImage();var i=this._imgCustom||this._dragSource;if(this._img=i.cloneNode(!0),this._copyStyle(i,this._img),this._img.style.top=this._img.style.left="-9999px",!this._imgCustom){var n=i.getBoundingClientRect(),s=this._getPoint(e);this._imgOffset={x:s.x-n.left,y:s.y-n.top},this._img.style.opacity=t._OPACITY.toString()}this._moveImage(e),document.body.appendChild(this._img)},t.prototype._destroyImage=function(){this._img&&this._img.parentElement&&this._img.parentElement.removeChild(this._img),this._img=null,this._imgCustom=null},t.prototype._moveImage=function(t){var e=this;requestAnimationFrame(function(){if(e._img){var i=e._getPoint(t,!0),n=e._img.style;n.position="absolute",n.pointerEvents="none",n.zIndex="999999",n.left=Math.round(i.x-e._imgOffset.x)+"px",n.top=Math.round(i.y-e._imgOffset.y)+"px"}})},t.prototype._copyProps=function(t,e,i){for(var n=0;n<i.length;n++){var s=i[n];t[s]=e[s]}},t.prototype._copyStyle=function(e,i){if(t._rmvAtts.forEach(function(t){i.removeAttribute(t)}),e instanceof HTMLCanvasElement){var n=e,s=i;s.width=n.width,s.height=n.height,s.getContext("2d").drawImage(n,0,0)}for(var o=getComputedStyle(e),r=0;r<o.length;r++){var a=o[r];a.indexOf("transition")<0&&(i.style[a]=o[a])}i.style.pointerEvents="none";for(r=0;r<e.children.length;r++)this._copyStyle(e.children[r],i.children[r])},t.prototype._dispatchEvent=function(e,i,n){if(e&&n){var s=document.createEvent("Event"),o=e.touches?e.touches[0]:e;return s.initEvent(i,!0,!0),s.button=0,s.which=s.buttons=1,this._copyProps(s,e,t._kbdProps),this._copyProps(s,o,t._ptProps),s.dataTransfer=this._dataTransfer,n.dispatchEvent(s),s.defaultPrevented}return!1},t.prototype._closestDraggable=function(t){for(;t;t=t.parentElement)if(t.hasAttribute("draggable")&&t.draggable)return t;return null},t}();i._instance=new i,i._THRESHOLD=5,i._OPACITY=.5,i._DBLCLICK=500,i._CTXMENU=900,i._ISPRESSHOLDMODE=!1,i._PRESSHOLDAWAIT=400,i._PRESSHOLDMARGIN=25,i._PRESSHOLDTHRESHOLD=0,i._rmvAtts="id,class,style,draggable".split(","),i._kbdProps="altKey,ctrlKey,metaKey,shiftKey".split(","),i._ptProps="pageX,pageY,clientX,clientY,screenX,screenY".split(","),t.DragDropTouch=i}(DragDropTouch||(DragDropTouch={}));

    </script>
    <script>/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */
var saveAs=saveAs||function(e){"use strict";if(typeof e==="undefined"||typeof navigator!=="undefined"&&/MSIE [1-9]\./.test(navigator.userAgent)){return}var t=e.document,n=function(){return e.URL||e.webkitURL||e},r=t.createElementNS("http://www.w3.org/1999/xhtml","a"),o="download"in r,a=function(e){var t=new MouseEvent("click");e.dispatchEvent(t)},i=/constructor/i.test(e.HTMLElement)||e.safari,f=/CriOS\/[\d]+/.test(navigator.userAgent),u=function(t){(e.setImmediate||e.setTimeout)(function(){throw t},0)},s="application/octet-stream",d=1e3*40,c=function(e){var t=function(){if(typeof e==="string"){n().revokeObjectURL(e)}else{e.remove()}};setTimeout(t,d)},l=function(e,t,n){t=[].concat(t);var r=t.length;while(r--){var o=e["on"+t[r]];if(typeof o==="function"){try{o.call(e,n||e)}catch(a){u(a)}}}},p=function(e){if(/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e.type)){return new Blob([String.fromCharCode(65279),e],{type:e.type})}return e},v=function(t,u,d){if(!d){t=p(t)}var v=this,w=t.type,m=w===s,y,h=function(){l(v,"writestart progress write writeend".split(" "))},S=function(){if((f||m&&i)&&e.FileReader){var r=new FileReader;r.onloadend=function(){var t=f?r.result:r.result.replace(/^data:[^;]*;/,"data:attachment/file;");var n=e.open(t,"_blank");if(!n)e.location.href=t;t=undefined;v.readyState=v.DONE;h()};r.readAsDataURL(t);v.readyState=v.INIT;return}if(!y){y=n().createObjectURL(t)}if(m){e.location.href=y}else{var o=e.open(y,"_blank");if(!o){e.location.href=y}}v.readyState=v.DONE;h();c(y)};v.readyState=v.INIT;if(o){y=n().createObjectURL(t);setTimeout(function(){r.href=y;r.download=u;a(r);h();c(y);v.readyState=v.DONE});return}S()},w=v.prototype,m=function(e,t,n){return new v(e,t||e.name||"download",n)};if(typeof navigator!=="undefined"&&navigator.msSaveOrOpenBlob){return function(e,t,n){t=t||e.name||"download";if(!n){e=p(e)}return navigator.msSaveOrOpenBlob(e,t)}}w.abort=function(){};w.readyState=w.INIT=0;w.WRITING=1;w.DONE=2;w.error=w.onwritestart=w.onprogress=w.onwrite=w.onabort=w.onerror=w.onwriteend=null;return m}(typeof self!=="undefined"&&self||typeof window!=="undefined"&&window||this.content);if(typeof module!=="undefined"&&module.exports){module.exports.saveAs=saveAs}else if(typeof define!=="undefined"&&define!==null&&define.amd!==null){define("FileSaver.js",function(){return saveAs})}
    </script>
    <script>'use strict';

const cardSpacing = [remToPx(2), remToPx(2)];

const cardStyleRegex = /\.domino-card-([a-zA-Z0-9-_]+)/;
function findCardStyleNames() {
    const styles = new Set();
    Array.from(document.styleSheets).forEach(sheet => {
        try {
            for (const rule of sheet.cssRules) {
                const names = rule.selectorText.match(cardStyleRegex);
                if (names)
                    styles.add(names[1]);
            }
        } catch (e) {}
    });
    return Array.from(styles);
}

function fakedownToTag(text, fd, tag) {
    const pattern = new RegExp(`${fd}([^${fd}]+)${fd}`, 'g');
    return text.replace(pattern, `<${tag}>$1</${tag}>`);
}

function parseFakedown(text) {
    if (text.startsWith('`'))
        return `<pre>${text.slice(1)}</pre>`;
    text = text.replace(/([^-])--([^-])/g, '$1‚Äî$2');
    text = fakedownToTag(text, '##', 'h3');
    text = fakedownToTag(text, '~~', 's');
    text = fakedownToTag(text, '__', 'strong');
    text = fakedownToTag(text, '\\*\\*', 'strong');
    text = fakedownToTag(text, '_', 'em');
    text = fakedownToTag(text, '\\*', 'em');
    text = text.replace(/\n/g, '<br>');
    return text;
}

const clicks = ['pointerdown', 'pointerup', 'click', 'touchstart'];
function setupClassHooks() {
    ALL('[data-block-clicks]').forEach(element => {
        for (let name of clicks)
            element.addEventListener(name, event => event.stopPropagation());
    });
    ALL('[data-click-to-hide]').forEach(element => {
        element.addEventListener('pointerdown', () => element.hidden = true);
        for (let name of clicks)
            element.addEventListener(name, event => event.stopPropagation());
    });
    ALL('[data-close-parent-screen]').forEach(element => {
        const screen = element.closest('.screen');
        element.addEventListener('click', () => screen.hidden = true);
        element.addEventListener('pointerdown', () => screen.hidden = true);
    });

    ALL('button').forEach(element => {
        if (!element.draggable)
            for (let name of clicks)
                element.addEventListener(name, event => event.stopPropagation());
    })
}

function updateDocumentVariables() {
    const vh = window.innerHeight / 100;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
}

function computeCardSize(parent) {
    const testCard = cloneTemplateElement('#card-template');
    parent.appendChild(testCard);
    const size = [testCard.clientWidth, testCard.clientHeight];
    parent.removeChild(testCard);
    return size;
}

async function extractDataFromHtmlFile(file) {
    const html = document.createElement('html');
    html.innerHTML = await textFromFile(file);
    return getElementJsonData(ONE('#data', html));
}

function exportProject() {
    setElementJsonData('#data', domino.getData());
    const clone = document.documentElement.cloneNode(true);
    ALL('[data-export-clear]', clone).forEach(element => element.innerHTML = '');
    ALL('[data-export-hide]', clone).forEach(element => element.hidden = true);
    const blob = new Blob([clone.outerHTML], {type: "text/html"});
    saveAs(blob, `domino-test.html`);
}

function addCardViewListeners(domino, view) {
    view.root.addEventListener('click', event => {
        if (!domino.unlocked) return;

        killEvent(event);
        domino.selectCardView(view);
        domino.focusCell(view.cell);
    });
    view.root.addEventListener('pointerdown', event => {
        if (!domino.unlocked) return;
        event.stopPropagation();
    });
    view.root.addEventListener('dragstart', event => {
        if (!domino.unlocked) return;

        event.dataTransfer.setData('card-origin-cell', JSON.stringify(view.cell));
        event.dataTransfer.setData('text/plain', view.card.text);
        event.dataTransfer.setData('card/move', '');

        const [x, y] = getElementCenter(view.root);
        event.dataTransfer.setDragImage(view.root, x, y);
    });
    view.root.addEventListener('dragover', event => {
        if (!domino.unlocked) return;

        killEvent(event);
        const newCard = event.dataTransfer.types.includes('card/new');
        event.dataTransfer.dropEffect = newCard ? 'none' : 'move'; 
    });
    view.root.addEventListener('drop', event => {
        if (!domino.unlocked) return;

        killEvent(event);
        if (!event.dataTransfer.types.includes('card/move'))
            return;

        const originJson = event.dataTransfer.getData('card-origin-cell');
        const cell = JSON.parse(originJson);
        domino.swapCells(cell, view.cell);
    });
}

function getCoordsFromHash() {
    try {
        const coords = location.hash.slice(1).split(',').map(i => parseInt(i) || 0);
        if (coords.length === 2) return coords;
    } catch(e) {}

    return [0, 0];
}

const dropContentTransformers = [
    ['card/new',      c => 'new card'],
    ['text/html',     c => c],
    ['text/uri-list', c => c.split('\n').filter(uri => !uri.startsWith('#')).map(uri => `<a href="${uri}">link</a>`)],
    ['text/plain',    c => c],
    ['text',          c => c],
];

class Domino {
    constructor() {
        this.cellToView = new CoordStore();
        this.focusedCell = [0, 0];
        this._panning = [0, 0];
        this.selectedCardView = undefined;
    }

    display(url, size=[800, 600]) {
        const frame = ONE('#display-frame');
        const [w, h] = size;
        ONE('#display-screen').hidden = false;
        frame.onerror = () => window.open(url);
        frame.src = url;
        frame.style.width = w;
        frame.style.height = h;
    }

    displayImage(url) {
        ONE('#display-image').src = url;
        ONE('#display-image-screen').hidden = false;
        ONE('#display-image').onerror = () => {
            ONE('#display-image-screen').hidden = true;
            window.open(url);
        };
    }

    runCommand(command) {
        if (command.startsWith('#')) {
            location.href = command;
        } else if (command.startsWith('image:')) {
            const src = command.slice(6);
            this.displayImage(src);
        } else if (command.startsWith('display:')) {
            const src = command.slice(8);
            this.display(src);
        } else if (command.length > 0) {
            window.open(command);
        }
    }

    set panning(position) {
        const [x, y] = position;
        this._panning = position;
        this.scene.style.transform = `translate(${x}px, ${y}px)`;
    }

    focusCell(coords) {
        if (this.pan) return;

        const element = this.editorScreen.hidden ? document.documentElement : this.editorPreview;
        this.focusedCell = coords;
        const [cx, cy] = getElementCenter(element);
        const [nx, ny] = this.grid.cellToPixel(coords);
        this.panning = [cx - nx, cy - ny];
        location.hash = coordsToKey(coords);
        const [q, r] = coords;
        ONE('#coords').innerHTML = `#${q},${r}`;
    }

    focusCellNoTransition(coords) {
        this.scene.classList.add('skiptransition');
        this.focusCell(coords);
        reflow(this.scene);
        this.scene.classList.remove('skiptransition');
    }

    addCard(card) {
        const view = new CardView(card);
    
        addCardViewListeners(this, view);
        this.scene.appendChild(view.root);
        this.moveCardToCell(view, card.cell);
    
        return view;
    }

    removeCard(view) {
        this.scene.removeChild(view.root);
        this.cellToView.delete(view.cell);

        if (this.editorScreen.activeView === view)
            this.editorScreen.setActiveView(undefined);
    }

    moveCardToCell(view, cell) {
        view.card.cell = cell;
        view.position = this.grid.cellToPixel(cell);
        this.cellToView.set(cell, view);
    }

    refreshCard(card) {
        this.cellToView.get(card.cell).refresh();
    }

    swapCells(a, b) {
        const aView = this.cellToView.get(a);
        const bView = this.cellToView.get(b);
    
        this.cellToView.delete(a);
        this.cellToView.delete(b);
    
        if (aView)
            this.moveCardToCell(aView, b);
        if (bView)
            this.moveCardToCell(bView, a);
    }

    clear() {
        this.deselect();
        this.scene.innerHTML = "";
        this.cellToView.store.clear();
        this.focusCell([0, 0]);
    }

    setData(data) {
        this.clear();
        for (let card of data.cards)
            this.addCard(card);
    }

    getData() {
        const views = Array.from(this.cellToView.store.values());
        const cards = views.map(view => view.card);
        return { cards };
    }

    setup() {
        this.editorScreen = new CardEditor();
        this.editorPreview = ONE('#editor-preview');
        this.scene = ONE('#scene');
        const [cw, ch] = computeCardSize(this.scene);
        const [sw, sh] = cardSpacing;
        this.grid = new HexGrid([cw + sw, ch + sh]);

        // hide fullscreen button if fullscreen is not possible
        if (!document.fullscreenEnabled)
            ONE('#fullscreen').hidden = true;

        this.cardbar = cloneTemplateElement('#cardbar-template');
        this.cardbar.id = 'cardbar';
        this.addDeleteCardIcon = ONE('#add-delete-icon');
        this.aboutScreen = ONE('#about-screen');

        this.lockedButton = ONE('#locked');
        this.unlockedButton = ONE('#unlocked');

        addListener(this.lockedButton,   'click', () => this.setUnlocked(true));
        addListener(this.unlockedButton, 'click', () => this.setUnlocked(false));

        const cardEditButton = ONE('#edit-card', this.cardbar);
        const importFile = ONE('#import-file');
        const screen = ONE('#screen');

        const onClickedEmptyCell = (event) => {
            killEvent(event);
            this.deselect();
            this.focusCell(pointerEventToCell(event));
        }

        // clicking listeners
        addListener(cardEditButton, 'click', () => this.editCardView(this.selectedCardView));
        addListener('#center',      'click', () => location.hash = '0,0');
        addListener('#open-about',  'click', () => this.aboutScreen.hidden = false);
        addListener('#reset',       'click', () => this.clear());
        addListener('#import',      'click', () => importFile.click());
        addListener('#export',      'click', () => exportProject());
        addListener('#fullscreen',  'click', () => toggleFullscreen());

        addListener(this.addDeleteCardIcon, 'pointerdown', event => event.stopPropagation());

        this.pan = undefined;
        window.addEventListener('pointerdown', event => {
            this.pan = {
                scenePosition: eventToElementPixel(event, this.scene),
                moves: 0,
            };
            this.scene.classList.add('skiptransition');
        });

        window.addEventListener('pointerup', () => {
            const click = this.pan && this.pan.moves < 5;
            this.pan = undefined;
            this.scene.classList.remove('skiptransition');
            if (click) 
                onClickedEmptyCell(event);
        });

        window.addEventListener('pointermove', event => {
            if (!this.pan) return;
            
            this.pan.moves += 1;

            // where we clicked in the scene
            const [wx, wy] = this.pan.scenePosition;
            // where we are in the scene now
            const [ax, ay] = eventToElementPixel(event, this.scene);
            // the error
            const [ex, ey] = [wx - ax, wy - ay];
            const [px, py] = this._panning;

            this.panning = [px - ex, py - ey];

            const [clientX, clientY] = getElementCenterClient(screen);
            const pixel = eventToElementPixel({ clientX, clientY }, this.scene);
            const [q, r] = this.grid.pixelToCell(pixel);
            this.focusedCell = [q, r];
            location.hash = coordsToKey([q, r]);
            ONE('#coords').innerHTML = `#${q},${r}`;
        });

        // file select listener
        addListener(importFile, 'change', async event => {
            this.setData(await extractDataFromHtmlFile(event.target.files[0]));
            importFile.value = null;
        });

        // dragging and dropping listeners
        setElementDragoverDropEffect(screen, 'copy');
        setElementDragoverDropEffect(this.editorScreen.root, 'none');
        setElementDragoverDropEffect(this.addDeleteCardIcon, 'move');

        const onDragFromNewCard = (event) => {
            event.dataTransfer.setData('card/new', '');
        }

        const onDroppedOnDelete = (event) => {
            killEvent(event);
            if (!event.dataTransfer.types.includes('card/move')) return;
            const originJson = event.dataTransfer.getData('card-origin-cell');
            const view = this.cellToView.get(JSON.parse(originJson));
            this.removeCard(view);
        }

        const pointerEventToCell = (event) => {
            const clickPixel = eventToElementPixel(event, this.scene);
            const clickCell = this.grid.pixelToCell(clickPixel);
            return clickCell;
        }

        const onDroppedOnEmptyCell = (event) => {
            killEvent(event);
            const dropCell = pointerEventToCell(event);
            
            const amMovingCard = event.dataTransfer.types.includes('card/move');
            const cellIsEmpty = !this.cellToView.has(dropCell);
    
            if (amMovingCard) {
                const originJson = event.dataTransfer.getData('card-origin-cell');
                const originCell = JSON.parse(originJson);
    
                this.swapCells(originCell, dropCell);
            } else if (cellIsEmpty) {
                let content = undefined;
    
                for (let [field, transformer] of dropContentTransformers) {
                    if (event.dataTransfer.types.includes(field)) {
                        const data = event.dataTransfer.getData(field);
                        content = transformer(data);
                        break;
                    }
                }
    
                if (content) {
                    const card = { text: content, type: this.editorScreen.types[0], cell: dropCell };
                    const view = this.addCard(card);
                    view.triggerSpawnAnimation();
                    this.editorScreen.setActiveView(view);
                }
            }
        }

        addListener(this.addDeleteCardIcon, 'dragstart', onDragFromNewCard);
        addListener(this.editorScreen.root, 'drop', killEvent);
        addListener(this.addDeleteCardIcon, 'drop', onDroppedOnDelete);
        addListener(screen,                 'drop', onDroppedOnEmptyCell);
    }

    setUnlocked(unlocked) {
        this.unlocked = unlocked;
        this.addDeleteCardIcon.hidden = !unlocked;

        this.lockedButton.hidden = unlocked;
        this.unlockedButton.hidden = !unlocked;

        ALL('.card').forEach(element => {
            element.setAttribute('draggable', unlocked ? 'true' : 'false');
        });
    }
    
    deselect() { this.selectCardView(undefined); }

    editFocusedCell() {
        const view = this.cellToView.get(this.focusedCell);
        if (view)
            this.editCardView(view);
    }

    editCardView(view) {
        if (!this.selectCardView) return;
        this.editorScreen.hidden = false;
        this.editorScreen.setActiveView(view);
        this.focusCell(view.cell, this.editorPreview);
    }

    selectCardView(view) {
        this.selectedCardView = view;
        this.cardbar.hidden = (view === undefined) || !this.unlocked;

        if (view)
            view.root.appendChild(this.cardbar);
    }
}

class CardEditor {
    constructor() {
        this.root = ONE('#editor-screen');
        this.contentInput = ONE('#content-input', this.root);
        this.typeButtons = {};

        this.types = findCardStyleNames();

        const names = ['text', 'icons', 'style'];
        const tabs = {};
        const pages = {};

        this.setPage = (name) => {
            names.forEach(name => {
                tabs[name].classList.remove('selected');
                pages[name].hidden = true;
            });
            tabs[name].classList.add('selected');
            pages[name].hidden = false;
        }

        for (let name of names) {
            tabs[name] = ONE(`#editor-tab-${name}`, this.root);
            pages[name] = ONE(`#editor-page-${name}`, this.root);
            addListener(tabs[name], 'click', () => this.setPage(name));
        }

        this.setPage(names[0]);

        this.iconRows = [];

        const refreshIcons = () => {
            const icons = [];
            this.iconRows.forEach(row => {
                icons.push({
                    icon: row.select.value,
                    command: row.command.value,
                });
            });
            this.activeView.card.icons = icons;
            domino.refreshCard(this.activeView.card);
        }

        for (let row of [1, 2, 3, 4]) {
            const select = ONE(`#editor-icon-select-${row}`, this.root);
            const command = ONE(`#editor-icon-command-${row}`, this.root);
            this.iconRows.push({ select, command });
            addListener(select, 'input', () => refreshIcons());
            addListener(command, 'input', () => refreshIcons());
        }

        const typeSelect = ONE('#type-select');

        for (let type of this.types) {
            const button = document.createElement('div');
            button.classList.add(`domino-card-${type}`, 'type-button');
            button.setAttribute('title', `change card style to ${type}`);
            typeSelect.appendChild(button);

            button.addEventListener('click', () => this.setType(type));
            this.typeButtons[type] = button;
        }

        this.contentInput.addEventListener('input', () => {
            if (!this.activeView) return;

            this.activeView.card.text = this.contentInput.value;
            domino.refreshCard(this.activeView.card);
        });
    }

    get hidden() { return this.root.hidden; }
    set hidden(value) { this.root.hidden = value; }

    setActiveView(view) {
        this.activeView = view;
        this.setPage('text');
        this.contentInput.select();
        this.refreshFromCard();
    }

    refreshFromCard() {
        if (!this.activeView) return;

        for (let type of this.types)
            this.typeButtons[type].classList.remove('selected');
        this.typeButtons[this.activeView.card.type].classList.add('selected');
        this.contentInput.value = this.activeView.card.text;

        this.iconRows.forEach(row => {
            row.select.value = "";
            row.command.value = "";
        })

        const icons = this.activeView.card.icons || [];
        icons.slice(0, 4).forEach((row, i) => {
            const { select, command } = this.iconRows[i];
            select.value = row.icon
            command.value = row.command;
        });
    }

    setType(type) {
        if (!this.activeView) return;

        this.activeView.card.type = type;
        this.refreshFromCard();
        domino.refreshCard(this.activeView.card);
    }
}

class CardView {
    constructor(card) {
        this._position = [0, 0];
        this._scale = 1;
        this.card = card;

        this.root = cloneTemplateElement('#card-template');
        this.text = ONE('.card-text', this.root);
        this.icons = ONE('.icon-bar', this.root);
        
        this.refresh();
    }

    get cell() { return this.card.cell; }

    set position(value) { 
        this._position = value;
        this.updateTransform();
    }

    set scale(value) { 
        this._scale = value;
        this.updateTransform();
    }

    triggerSpawnAnimation() {
        this.scale = 0;
        reflow(this.root);
        this.scale = 1;
    }

    updateTransform() {
        const [x, y] = this._position;
        const position = `translate(calc(${x}px - 50%), calc(${y}px - 50%))`;
        const scaling = `scale(${this._scale}, ${this._scale})`;
        this.root.style.transform = `${position} ${scaling}`;
    }

    refresh() {
        const types = domino.editorScreen.types;
        this.root.classList.remove(...types.map(t => `domino-card-${t}`));
        this.root.classList.add(`domino-card-${this.card.type}`);
        this.text.innerHTML = parseFakedown(this.card.text);

        this.icons.innerHTML = "";
        (this.card.icons || []).forEach(row => {
            const button = document.createElement('a');
            button.innerHTML = row.icon;
            addListener(button, 'pointerdown', e => e.stopPropagation());
            addListener(button, 'click', e => { killEvent(e); domino.runCommand(row.command)});
            this.icons.appendChild(button);
            button.href = row.command;

            if (row.icon.length === 0)
                button.classList.add('blank');
            if (row.command.length === 0)
                button.classList.add('cosmetic');
        });
    }
}

const domino = new Domino();

async function loaded() {
    setupClassHooks();

    domino.setup();

    window.addEventListener('resize', updateDocumentVariables);
    updateDocumentVariables();

    // center the currently selected cell
    const jumpFromHash = () => domino.focusCell(getCoordsFromHash());
    window.addEventListener('hashchange', jumpFromHash);
    window.addEventListener('resize', jumpFromHash);
    
    // load data from embeded #data script tag
    const coords = getCoordsFromHash();
    const data = getElementJsonData('#data');
    domino.setData(data);
    domino.setUnlocked(false);
    domino.focusCellNoTransition(coords);

    // keyboard shortcuts
    window.addEventListener('keydown', event => {
        if (event.key === 'Escape')
            domino.editorScreen.hidden = true;

        if (!domino.editorScreen.hidden) return;

        if (event.key === 'e') {
            killEvent(event);
            domino.editFocusedCell();
        }

        const [q, r] = domino.focusedCell;
        if (event.key === 'ArrowLeft')  domino.focusCell([q - 1, r + 1]);
        if (event.key === 'ArrowRight') domino.focusCell([q + 1, r - 1]);
        if (event.key === 'ArrowUp')    domino.focusCell([q + 0, r - 1]);
        if (event.key === 'ArrowDown')  domino.focusCell([q + 0, r + 1]);
    });
}

    </script>
  </head>
  <body class="no-select" onload="loaded()">
    <div id="templates" hidden>
      <div class="card" id="card-template" draggable="true">
        <div class="card-text"></div>
        <div class="card-icon-bar icon-bar"></div>
      </div>
      <div class="card-edit-bar icon-bar" id="cardbar-template" hidden>
        <button id="edit-card" title="edit this card">üìù</button>
      </div>
    </div>
    <div id="screen"></div>
    <main id="scene" data-export-clear></main>
    <div id="coords">#0,0</div>
    <div class="icon-bar" id="toolbar">
      <button id="open-about" title="information about this tool">‚ùî</button>
      <button id="center" title="jump to center">üè†</button>
      <button id="add-delete-icon" hidden draggable="true" title="drag a new card from here or a drop an unwanted card">üóÉÔ∏è</button>
      <button id="fullscreen" title="toggle fullscreen" hidden>üí¢</button>
      <button id="unlocked" title="prevent accidental editing">üîì</button>
      <button id="locked" title="enable editing" hidden>üîí</button>
    </div>
    <div class="screen" id="display-screen" hidden data-click-to-hide>
      <iframe id="display-frame" data-block-clicks allow="autoplay"></iframe>
    </div>
    <div class="screen" id="display-image-screen" hidden data-click-to-hide>
      <image id="display-image"></image>
    </div>
    <div class="screen" id="editor-screen" hidden data-click-to-hide>
      <div id="editor-preview"></div>
      <div id="editor-section" data-block-clicks>
        <div id="editor-tabs">
          <div id="editor-tab-text">TEXT</div>
          <div id="editor-tab-icons">ICONS</div>
          <div id="editor-tab-style">STYLE</div>
        </div>
        <div class="editor-page" id="editor-page-text" hidden>
          <textarea id="content-input"></textarea>
        </div>
        <div class="editor-page" id="editor-page-icons" hidden>
          <input class="icon-select" id="editor-icon-select-1" type="text">
          <input class="icon-command" id="editor-icon-command-1" type="text">
          <input class="icon-select" id="editor-icon-select-2" type="text">
          <input class="icon-command" id="editor-icon-command-2" type="text">
          <input class="icon-select" id="editor-icon-select-3" type="text">
          <input class="icon-command" id="editor-icon-command-3" type="text">
          <input class="icon-select" id="editor-icon-select-4" type="text">
          <input class="icon-command" id="editor-icon-command-4" type="text">
        </div>
        <div class="editor-page" id="editor-page-style" hidden>
          <div id="type-select" data-export-clear></div>
        </div>
      </div>
    </div>
    <div class="screen" id="about-screen" hidden data-click-to-hide data-export-hide>
      <div class="full-panel" data-block-clicks>
        <button data-close-parent-screen>exit window</button>
        <div id="version">
          version‚Äîbeta-1 (2020-3-8)</div>
        <div id="project-menu">
          <button id="import" title="import a domino project">üìÇ import from html</button>
          <button id="export" title="export as html">üì¶ export to html</button>
          <button id="reset" title="remove all cards">‚ùå remove all cards</button>
        </div>
        <input id="import-file" type="file" accept=".html" hidden><h1>domino</h1>
<h2>about</h2>
<p>domino is a tool for collaging fragmented thoughts into a larger idea.
it's essentially a tool for making a particular kind of mindmap and sharing it
as a page on your website or itch.io.</p>
<p>i'm <a href="https://twitter.com/ragzouken">mark wonnacott a.k.a candle</a> and i created domino as a
<a href="https://kool.tools/2020/02/26/speculations.html">response to my frustration</a> trying to express myself in Emilie Reed's
writing jams.</p>
<h2>info</h2>
<p>the original source code for domino is available on <a href="https://github.com/Ragzouken/domino">github</a>.</p>
<h2>thanks</h2>
<p><strong>Em Reed</strong> for <a href="https://itch.io/jam/manifesto-jam">Manifesto Jam</a> and <a href="https://itch.io/jam/speculation-jam">Speculation Jam</a> which have
deeply inspired me and also motivated the creation of this tool. also for
certain flippant comments that pushed me into developing web based tools.</p>
<p><strong>Max</strong> for <a href="https://github.com/synth-ruiner/image-to-bitsy">image to bitsy</a> whose source code was a valuable reference for
developing web tools. also for feedback and bug reports.</p>
<p><strong>sg</strong> for <a href="https://zenzoa.itch.io/mosi">m√¥si</a> whose source code was a valuable reference for developing
web tools. also for feedback and bug reports.</p>
<p><strong>Kris De Decker</strong> for <a href="https://solar.lowtechmagazine.com/">LOW‚ÜêTECH MAGAZINE</a> which continues to inspire me to
think about how computing and software can and must change in the future. also
the aesthetic inspiration for the default style in domino.</p>
<p><strong>Chris Klimas</strong> for <a href="https://twinery.org/">Twine</a> whose card based layout and ecosystem of user
customisation is an inspiration to domino.</p>
<h2>attribution</h2>
<ul>
<li>Bernardo Castilho‚Äî<a href="https://github.com/Bernardo-Castilho/dragdroptouch">DragDropTouch</a></li>
<li>Eli Grey‚Äî<a href="https://github.com/eligrey/FileSaver.js/">FileSaver.js</a></li>
<li>Cyreal‚Äî<a href="https://fonts.google.com/specimen/Lora">Lora font</a></li>
<li>Wouter de Bruijn‚Äî<a href="https://creativecommons.org/licenses/by-nc-sa/2.0/">twitter card image</a> (cropped and recolored under <a href="https://creativecommons.org/licenses/by-nc-sa/2.0/">CC BY-NC-SA</a>)</li>
</ul>

      </div>
    </div>
  </body>
</html>