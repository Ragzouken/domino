<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>domino</title>
    <script id="data" type="text/json">{"cards": {"0": {"text": "hello", "type": "red"}}, "views": [{"card": "0", "cell": [0, 0]}]}</script>
    <link href="https://fonts.googleapis.com/css?family=Lora&display=swap" rel="stylesheet">
    <style>[hidden] { display: none !important; }

:root {
    --light: rgb(255, 245, 209);
    --dark: rgb(240, 248, 255);
    --red: #d11305;
    --green: #006951;
    --blue: #162dab;
  
    --red-stiple: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAHUlEQVQYV2O8JMKapvfm9ywGKGCEMTAEYCoxVAAAT4UIBcKIFHsAAAAASUVORK5CYII=);
    --green-stiple: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAHElEQVQYV2NkyOJpYJj2pYEBChhhDEwBqEoMFQD4ngYFtMbpQAAAAABJRU5ErkJggg==);
    --blue-stiple: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAHElEQVQYV2NkSLmZxjBHfRYDFDDCGJgCUJUYKgD+BgYFL5bp8wAAAABJRU5ErkJggg==);
    --black-stiple: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAHElEQVQYV2NkYGBIY2BgmMUABYwwBjYBsEoMFQBSHgIFwNTCZwAAAABJRU5ErkJggg==);

    --stipple-color: var(--red);
    --stipple-gap: 4px;
    --stipple-background-size: calc(var(--stipple-gap) * 2) calc(var(--stipple-gap) * 2);

    --stipple-gradient: radial-gradient(var(--stipple-color) 15%, transparent 16%);
    --stipple-background:
        var(--stipple-gradient) 0 0,
        var(--stipple-gradient) var(--stipple-gap) var(--stipple-gap);

    --card-width: 15rem;
    --card-height: calc(var(--card-width) * .6);
}

html {
    background: var(--light);

    font-family: lora;
    font-size: 1.1em;
}

main {
    transition: transform .2s ease-in-out;
    width: 0;
    height: 0;
}

.black { background: var(--black-stiple) repeat; }
.red   { background: var(--red-stiple)   repeat; }
.green { background: var(--green-stiple) repeat; }
.blue  { background: var(--blue-stiple)  repeat; }

body {
    overflow: hidden;
}

hr {
    border-top: 2px solid black;
}

#debug {
    position: absolute;
    display: none;
}

#sidebar {
    position: absolute;
    margin: 1em;
    padding: 1em;
    
    background: var(--dark);
}

#content-input {
    display: block;
    width: var(--card-width);
    height: var(--card-height);
}

.card {
    position: absolute;
    cursor: pointer;

    transition: transform .2s ease-in-out;

    padding: 1em;
    width: calc(var(--card-width) - 2em);
    height: calc(var(--card-height) - 2em);

    display: inline-block;
    margin: 0 0 1em;
    word-wrap: break-word;

    border-bottom: 2px solid black;

    text-shadow: 
        0 0 3px var(--light), 
        0 0 3px var(--light), 
        0 0 3px var(--light), 
        0 0 3px var(--light),
        0 0 3px var(--light), 
        0 0 3px var(--light), 
        0 0 3px var(--light), 
        0 0 3px var(--light);
}

.card::selection {
    background: Highlight;
    color: HighlightText;
    text-shadow: none;
}

.card.selected {
    outline: 2px dashed var(--red);
}

.card > h3 {
    display: inline;
    font-size: 1em;
}

.card > h3::after {
    font-weight: normal;
    content: " â€” ";
}

.skiptransition {
    transition: none !important;
}

    </style>
    <script>var DragDropTouch;!function(t){"use strict";var e=function(){function t(){this._dropEffect="move",this._effectAllowed="all",this._data={}}return Object.defineProperty(t.prototype,"dropEffect",{get:function(){return this._dropEffect},set:function(t){this._dropEffect=t},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"effectAllowed",{get:function(){return this._effectAllowed},set:function(t){this._effectAllowed=t},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"types",{get:function(){return Object.keys(this._data)},enumerable:!0,configurable:!0}),t.prototype.clearData=function(t){null!=t?delete this._data[t]:this._data=null},t.prototype.getData=function(t){return this._data[t]||""},t.prototype.setData=function(t,e){this._data[t]=e},t.prototype.setDragImage=function(t,e,n){var s=i._instance;s._imgCustom=t,s._imgOffset={x:e,y:n}},t}();t.DataTransfer=e;var i=function(){function t(){if(this._lastClick=0,t._instance)throw"DragDropTouch instance already created.";var e=!1;if(document.addEventListener("test",function(){},{get passive(){return e=!0,!0}}),"ontouchstart"in document){var i=document,n=this._touchstart.bind(this),s=this._touchmove.bind(this),o=this._touchend.bind(this),r=!!e&&{passive:!1,capture:!1};i.addEventListener("touchstart",n,r),i.addEventListener("touchmove",s,r),i.addEventListener("touchend",o),i.addEventListener("touchcancel",o)}}return t.getInstance=function(){return t._instance},t.prototype._touchstart=function(e){var i=this;if(this._shouldHandle(e)){if(Date.now()-this._lastClick<t._DBLCLICK&&this._dispatchEvent(e,"dblclick",e.target))return e.preventDefault(),void this._reset();this._reset();var n=this._closestDraggable(e.target);n&&(this._dispatchEvent(e,"mousemove",e.target)||this._dispatchEvent(e,"mousedown",e.target)||(this._dragSource=n,this._ptDown=this._getPoint(e),this._lastTouch=e,e.preventDefault(),setTimeout(function(){i._dragSource==n&&null==i._img&&i._dispatchEvent(e,"contextmenu",n)&&i._reset()},t._CTXMENU),t._ISPRESSHOLDMODE&&(this._pressHoldInterval=setTimeout(function(){i._isDragEnabled=!0,i._touchmove(e)},t._PRESSHOLDAWAIT))))}},t.prototype._touchmove=function(t){if(this._shouldCancelPressHoldMove(t))this._reset();else if(this._shouldHandleMove(t)||this._shouldHandlePressHoldMove(t)){var e=this._getTarget(t);if(this._dispatchEvent(t,"mousemove",e))return this._lastTouch=t,void t.preventDefault();this._dragSource&&!this._img&&this._shouldStartDragging(t)&&(this._dispatchEvent(t,"dragstart",this._dragSource),this._createImage(t),this._dispatchEvent(t,"dragenter",e)),this._img&&(this._lastTouch=t,t.preventDefault(),e!=this._lastTarget&&(this._dispatchEvent(this._lastTouch,"dragleave",this._lastTarget),this._dispatchEvent(t,"dragenter",e),this._lastTarget=e),this._moveImage(t),this._isDropZone=this._dispatchEvent(t,"dragover",e))}},t.prototype._touchend=function(t){if(this._shouldHandle(t)){if(this._dispatchEvent(this._lastTouch,"mouseup",t.target))return void t.preventDefault();this._img||(this._dragSource=null,this._dispatchEvent(this._lastTouch,"click",t.target),this._lastClick=Date.now()),this._destroyImage(),this._dragSource&&(t.type.indexOf("cancel")<0&&this._isDropZone&&this._dispatchEvent(this._lastTouch,"drop",this._lastTarget),this._dispatchEvent(this._lastTouch,"dragend",this._dragSource),this._reset())}},t.prototype._shouldHandle=function(t){return t&&!t.defaultPrevented&&t.touches&&t.touches.length<2},t.prototype._shouldHandleMove=function(e){return!t._ISPRESSHOLDMODE&&this._shouldHandle(e)},t.prototype._shouldHandlePressHoldMove=function(e){return t._ISPRESSHOLDMODE&&this._isDragEnabled&&e&&e.touches&&e.touches.length},t.prototype._shouldCancelPressHoldMove=function(e){return t._ISPRESSHOLDMODE&&!this._isDragEnabled&&this._getDelta(e)>t._PRESSHOLDMARGIN},t.prototype._shouldStartDragging=function(e){var i=this._getDelta(e);return i>t._THRESHOLD||t._ISPRESSHOLDMODE&&i>=t._PRESSHOLDTHRESHOLD},t.prototype._reset=function(){this._destroyImage(),this._dragSource=null,this._lastTouch=null,this._lastTarget=null,this._ptDown=null,this._isDragEnabled=!1,this._isDropZone=!1,this._dataTransfer=new e,clearInterval(this._pressHoldInterval)},t.prototype._getPoint=function(t,e){return t&&t.touches&&(t=t.touches[0]),{x:e?t.pageX:t.clientX,y:e?t.pageY:t.clientY}},t.prototype._getDelta=function(e){if(t._ISPRESSHOLDMODE&&!this._ptDown)return 0;var i=this._getPoint(e);return Math.abs(i.x-this._ptDown.x)+Math.abs(i.y-this._ptDown.y)},t.prototype._getTarget=function(t){for(var e=this._getPoint(t),i=document.elementFromPoint(e.x,e.y);i&&"none"==getComputedStyle(i).pointerEvents;)i=i.parentElement;return i},t.prototype._createImage=function(e){this._img&&this._destroyImage();var i=this._imgCustom||this._dragSource;if(this._img=i.cloneNode(!0),this._copyStyle(i,this._img),this._img.style.top=this._img.style.left="-9999px",!this._imgCustom){var n=i.getBoundingClientRect(),s=this._getPoint(e);this._imgOffset={x:s.x-n.left,y:s.y-n.top},this._img.style.opacity=t._OPACITY.toString()}this._moveImage(e),document.body.appendChild(this._img)},t.prototype._destroyImage=function(){this._img&&this._img.parentElement&&this._img.parentElement.removeChild(this._img),this._img=null,this._imgCustom=null},t.prototype._moveImage=function(t){var e=this;requestAnimationFrame(function(){if(e._img){var i=e._getPoint(t,!0),n=e._img.style;n.position="absolute",n.pointerEvents="none",n.zIndex="999999",n.left=Math.round(i.x-e._imgOffset.x)+"px",n.top=Math.round(i.y-e._imgOffset.y)+"px"}})},t.prototype._copyProps=function(t,e,i){for(var n=0;n<i.length;n++){var s=i[n];t[s]=e[s]}},t.prototype._copyStyle=function(e,i){if(t._rmvAtts.forEach(function(t){i.removeAttribute(t)}),e instanceof HTMLCanvasElement){var n=e,s=i;s.width=n.width,s.height=n.height,s.getContext("2d").drawImage(n,0,0)}for(var o=getComputedStyle(e),r=0;r<o.length;r++){var a=o[r];a.indexOf("transition")<0&&(i.style[a]=o[a])}i.style.pointerEvents="none";for(r=0;r<e.children.length;r++)this._copyStyle(e.children[r],i.children[r])},t.prototype._dispatchEvent=function(e,i,n){if(e&&n){var s=document.createEvent("Event"),o=e.touches?e.touches[0]:e;return s.initEvent(i,!0,!0),s.button=0,s.which=s.buttons=1,this._copyProps(s,e,t._kbdProps),this._copyProps(s,o,t._ptProps),s.dataTransfer=this._dataTransfer,n.dispatchEvent(s),s.defaultPrevented}return!1},t.prototype._closestDraggable=function(t){for(;t;t=t.parentElement)if(t.hasAttribute("draggable")&&t.draggable)return t;return null},t}();i._instance=new i,i._THRESHOLD=5,i._OPACITY=.5,i._DBLCLICK=500,i._CTXMENU=900,i._ISPRESSHOLDMODE=!1,i._PRESSHOLDAWAIT=400,i._PRESSHOLDMARGIN=25,i._PRESSHOLDTHRESHOLD=0,i._rmvAtts="id,class,style,draggable".split(","),i._kbdProps="altKey,ctrlKey,metaKey,shiftKey".split(","),i._ptProps="pageX,pageY,clientX,clientY,screenX,screenY".split(","),t.DragDropTouch=i}(DragDropTouch||(DragDropTouch={}));

    </script>
    <script>/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */
var saveAs=saveAs||function(e){"use strict";if(typeof e==="undefined"||typeof navigator!=="undefined"&&/MSIE [1-9]\./.test(navigator.userAgent)){return}var t=e.document,n=function(){return e.URL||e.webkitURL||e},r=t.createElementNS("http://www.w3.org/1999/xhtml","a"),o="download"in r,a=function(e){var t=new MouseEvent("click");e.dispatchEvent(t)},i=/constructor/i.test(e.HTMLElement)||e.safari,f=/CriOS\/[\d]+/.test(navigator.userAgent),u=function(t){(e.setImmediate||e.setTimeout)(function(){throw t},0)},s="application/octet-stream",d=1e3*40,c=function(e){var t=function(){if(typeof e==="string"){n().revokeObjectURL(e)}else{e.remove()}};setTimeout(t,d)},l=function(e,t,n){t=[].concat(t);var r=t.length;while(r--){var o=e["on"+t[r]];if(typeof o==="function"){try{o.call(e,n||e)}catch(a){u(a)}}}},p=function(e){if(/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e.type)){return new Blob([String.fromCharCode(65279),e],{type:e.type})}return e},v=function(t,u,d){if(!d){t=p(t)}var v=this,w=t.type,m=w===s,y,h=function(){l(v,"writestart progress write writeend".split(" "))},S=function(){if((f||m&&i)&&e.FileReader){var r=new FileReader;r.onloadend=function(){var t=f?r.result:r.result.replace(/^data:[^;]*;/,"data:attachment/file;");var n=e.open(t,"_blank");if(!n)e.location.href=t;t=undefined;v.readyState=v.DONE;h()};r.readAsDataURL(t);v.readyState=v.INIT;return}if(!y){y=n().createObjectURL(t)}if(m){e.location.href=y}else{var o=e.open(y,"_blank");if(!o){e.location.href=y}}v.readyState=v.DONE;h();c(y)};v.readyState=v.INIT;if(o){y=n().createObjectURL(t);setTimeout(function(){r.href=y;r.download=u;a(r);h();c(y);v.readyState=v.DONE});return}S()},w=v.prototype,m=function(e,t,n){return new v(e,t||e.name||"download",n)};if(typeof navigator!=="undefined"&&navigator.msSaveOrOpenBlob){return function(e,t,n){t=t||e.name||"download";if(!n){e=p(e)}return navigator.msSaveOrOpenBlob(e,t)}}w.abort=function(){};w.readyState=w.INIT=0;w.WRITING=1;w.DONE=2;w.error=w.onwritestart=w.onprogress=w.onwrite=w.onabort=w.onerror=w.onwriteend=null;return m}(typeof self!=="undefined"&&self||typeof window!=="undefined"&&window||this.content);if(typeof module!=="undefined"&&module.exports){module.exports.saveAs=saveAs}else if(typeof define!=="undefined"&&define!==null&&define.amd!==null){define("FileSaver.js",function(){return saveAs})}
    </script>
    <script>const cube_directions = [
    [+1, -1, 0], [+1, 0, -1], [0, +1, -1], 
    [-1, +1, 0], [-1, 0, +1], [0, -1, +1], 
];

const colors = ['black', 'red', 'green', 'blue'];

class CardView {
    constructor(cell, card) {
        this.cell = cell;
        this.card = card;

        this.root = document.createElement('div');
        this.root.classList.add('card');
        this.root.draggable = true;

        this.refresh();
    }

    setPosition(x, y, scale=1) {
        const transform = `translate(calc(${x}px - 50%), calc(${y}px - 50%)) scale(${scale}, ${scale})`;
        this.root.style.transform = transform;
    }

    refresh() {
        this.root.classList.remove(...colors);
        this.root.classList.add(this.card.type);
        this.root.innerHTML = this.card.text;
    }
}

async function playableHTMLBlob(json)
{
    const doc = document.documentElement.cloneNode(true);
    const data = doc.querySelector("#data");
    data.innerHTML = `\n${json}\n`;
    doc.querySelector("main").innerHTML = "";

    return new Blob([doc.innerHTML], {type: "text/html"});
}

async function loaded() {
    const typeSelect = document.querySelector('#type-select');
    for (let type of colors) {
        const option = document.createElement('option');
        option.value = type;
        option.innerHTML = type;
        typeSelect.appendChild(option);
    }

    const main = document.querySelector('main');

    const testCard = document.createElement('div');
    testCard.classList.add('card');
    main.appendChild(testCard);

    const grid = new HexGrid([testCard.clientWidth, testCard.clientHeight], [32, 32]);
    const cellToView = new CoordStore();

    main.removeChild(testCard);

    document.querySelector('#download').addEventListener('click', async () => {
        const cardData = {};
        const viewData = [];

        const cardToId = new Map();
        let nextId = 0;
        function generateID() {
            nextId += 1;
            return (nextId - 1).toString();
        }
        function getCardId(card) {
            let id = cardToId.get(card) || generateID();
            cardToId.set(card, id);
            cardData[id] = card;
            return id;
        }
        
        cellToView.store.forEach((view) => {
            viewData.push({ cell: view.cell, card: getCardId(view.card) });
        });

        const json = JSON.stringify({
           cards: cardData,
           views: viewData, 
        });

        document.querySelector('#data').innerHTML = json;

        const name = "test";
        const blob = await playableHTMLBlob(json);
        saveAs(blob, `domino-${name}.html`);
    });

    function setPan(x, y) {
        main.style.transform = `translate(${x}px, ${y}px)`;
    }

    function moveViewToCell(view, cell, scale=1) {
        view.cell = cell;
        console.assert(!cellToView.has(cell) || cellToView.get(cell) === view);
        cellToView.set(cell, view);

        const [x, y] = grid.cellToPixel(cell);
        view.setPosition(x, y, scale);
    }

    const sidebar = document.querySelector('#sidebar');
    const delCard = document.querySelector('#del-card');
    
    sidebar.addEventListener('dragover', event => {
        event.preventDefault();
        event.stopPropagation();

        event.dataTransfer.dropEffect = 'none';
    });

    sidebar.addEventListener('drop', event => {
        event.preventDefault();
        event.stopPropagation();
    });

    delCard.addEventListener('dragover', event => {
        event.preventDefault();
        event.stopPropagation();

        event.dataTransfer.dropEffect = 'move';
    });

    delCard.addEventListener('drop', event => {
        event.preventDefault();
        event.stopPropagation();

        if (event.dataTransfer.types.includes('card/move')) {
            const originJson = event.dataTransfer.getData('card-origin-cell');
            const view = cellToView.get(JSON.parse(originJson));
            removeCardView(view);
        }
    });

    const addCard = document.querySelector('#add-card');
    const contentInput = document.querySelector('#content-input');
    let selectedCard = undefined;

    contentInput.addEventListener('input', () => {
        if (!selectedCard) return;

        selectedCard.text = contentInput.value;
        updateAllViewContent();
    });

    typeSelect.addEventListener('change', () => {
        if (!selectedCard) return;

        console.log("change...");
        selectedCard.type = typeSelect.value;
        updateAllViewContent();
    });

    function selectCard(card) {
        selectedCard = card;

        typeSelect.hidden = card === undefined;
        contentInput.hidden = card === undefined;

        if (card) {
            typeSelect.value = card.type;
            contentInput.value = card.text;
        }

        updateAllViewContent();
    }

    function updateAllViewContent() {
        cellToView.store.forEach((view, cell) => {
            view.refresh();

            view.root.classList.remove('selected');
            if (view.card === selectedCard)
                view.root.classList.add('selected');
        });
    }

    addCard.addEventListener('dragstart', event => {
        event.dataTransfer.setData('card/new', '');
    });

    function centerCell(coords) {
        const [cx, cy] = [document.documentElement.clientWidth / 2, document.documentElement.clientHeight / 2];
        const [nx, ny] = grid.cellToPixel(coords);
        setPan(cx - nx , cy - ny);
    }

    function addCardView(card, cell) {
        const view = new CardView(cell, card);

        view.root.addEventListener('dragstart', event => {
            event.dataTransfer.setData('card-origin-cell', JSON.stringify(view.cell));
            event.dataTransfer.setData('text/plain', view.card.text);
            event.dataTransfer.setData('card/move', '');

            const [x, y] = [view.root.clientWidth / 2, view.root.clientHeight / 2];
            event.dataTransfer.setDragImage(view.root, x, y);
        });

        view.root.addEventListener('dragover', event => {
            event.preventDefault();
            event.stopPropagation();

            const newCard = event.dataTransfer.types.includes('card/new');
            event.dataTransfer.dropEffect = newCard ? 'none' : 'move'; 
        });

        // shouldn't need this but it's more foolproof...
        view.root.addEventListener('drop', event => {
            event.stopPropagation();
            event.preventDefault();

            if (!event.dataTransfer.types.includes('card/move'))
                return;

            const originJson = event.dataTransfer.getData('card-origin-cell');
            const cell = JSON.parse(originJson);
            swapCells(cell, view.cell);
        });

        main.appendChild(view.root);

        view.root.addEventListener('click', () => {
            selectCard(view.card);
            centerCell(view.cell);
        });

        moveViewToCell(view, cell);

        return view;
    }

    function removeCardView(view) {
        main.removeChild(view.root);
        cellToView.delete(view.cell);
        if (selectedCard === view.card)
            selectCard(undefined);
    }

    function swapViewCells(a, b) {
        if (coordsAreEqual(a, b))
            return;
        
        const aView = cellToView.get(a);
        const bView = cellToView.get(b);

        cellToView.delete(a);
        cellToView.delete(b);

        if (aView)
            moveViewToCell(aView, b);
        if (bView)
            moveViewToCell(bView, a);
    }

    document.addEventListener('dragover', event => {
        event.preventDefault();
        event.stopPropagation();
        event.dataTransfer.dropEffect = 'copy';
    });

    document.addEventListener('drop', async event => {
        event.preventDefault();

        const rect = main.getBoundingClientRect();
        const dropPixel = [event.clientX - rect.x, event.clientY - rect.y];
        const dropCell = grid.pixelToCell(dropPixel);

        if (event.dataTransfer.types.includes('card/move')) {
            const originJson = event.dataTransfer.getData('card-origin-cell');
            const originCell = JSON.parse(originJson);

            swapViewCells(originCell, dropCell);
        } else if (!cellToView.has(dropCell)) {
            const types = event.dataTransfer.types;
            let content = undefined;

            if (types.includes('card/new')) {
                content = "new card";
            } else if (types.includes('text/html')) {
                content = event.dataTransfer.getData('text/html');
            } else if (types.includes('text/uri-list')) {
                content = event.dataTransfer
                    .getData('text/uri-list')
                    .split('\n')
                    .filter(uri => !uri.startsWith('#'))
                    .map(uri => `<a href="${uri}">link</a>`);
            } else if (types.includes('text/plain')) {
                content = event.dataTransfer.getData('text/plain');
            } else if (types.includes('text')) {
                content = event.dataTransfer.getData('text');
            }

            if (content) {
                const view = addCardView({text: content, type: 'black'}, dropCell);
                moveViewToCell(view, view.cell, 0);
                await sleep(10);
                moveViewToCell(view, view.cell, 1);
                selectCard(view.card);
            }
        }
    });

    function loadData() {
        const json = document.querySelector('#data').innerText;
        const data = JSON.parse(json);

        for (let view of data.views) {
            addCardView(data.cards[view.card], view.cell);
        }
        updateAllViewContent();
    }
    
    loadData();
    selectCard(undefined);

    main.classList.add('skiptransition');
    centerCell([0, 0]);
    await sleep(10);
    main.classList.remove('skiptransition');
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function coordsAreEqual(a, b) {
    if (a.length !== b.length) 
        return false;

    for (let i = 0; i < a.length; ++i)
        if (a[i] !== b[1])
            return false;
    
    return true;
}

function coordsToKey(coords) {
    return coords.join(',');
}

class CoordStore {
    constructor() { this.store = new Map(); }
    get size() { return this.store.size; }
    get(coords) { return this.store.get(coordsToKey(coords)); }
    set(coords, value) { return this.store.set(coordsToKey(coords), value); }
    delete(coords) { return this.store.delete(coordsToKey(coords)); }
    has(coords) { return this.store.has(coordsToKey(coords)); }
}

// based on https://www.redblobgames.com/grids/hexagons/
class HexGrid {
    constructor(cellSize, cellSpacing=[0, 0]) {
        this.cellSize = cellSize;
        this.cellSpacing = cellSpacing;
    }

    cellToPixel(cellCoords) {
        const [q, r] = cellCoords;
        const [w, h] = this.cellSize;
        const [hs, vs] = this.cellSpacing;

        const x = q * (w + hs);
        const y = q * (h + vs) * .5 + r * (h + vs);
        return [x, y];
    }

    pixelDebug(pixelCoords) {
        let [x, y] = pixelCoords;
        const [w, h] = this.cellSize;
        const [hs, vs] = this.cellSpacing;

        const q = x / (w + hs);
        const r = (y - (q * (h + vs) * .5)) / (h + vs);

        return [q, r];
    }

    pixelToCell(pixelCoords) {
        const [x, y] = pixelCoords;
        const [w, h] = this.cellSize;
        const [hs, vs] = this.cellSpacing;

        const q = x / (w + hs);
        const r = (y - (q * (h + vs) * .5)) / (h + vs);

        const cx = q;
        const cy = r;
        const cz = 0 - cx - cy;

        let rx = Math.round(cx);
        let ry = Math.round(cy);
        let rz = Math.round(cz);

        var x_diff = Math.abs(rx - cx);
        var y_diff = Math.abs(ry - cy);
        var z_diff = Math.abs(rz - cz);

        if (x_diff > y_diff & x_diff > z_diff) {
            rx = -ry-rz
        } else if (y_diff > z_diff) {
            ry = -rx-rz
        } else {
            rz = -rx-ry
        }

        return [rx, ry];
    }
}

    </script>
  </head>
  <body onload="loaded()"><span id="debug">debug</span>
    <main></main>
    <div id="sidebar">
      <button id="add-card" draggable="true">drag to add card</button>
      <button id="del-card">drop card to delete</button>
      <hr>
      <select id="type-select"></select>
      <textarea id="content-input" hidden></textarea>
      <hr>
      <button id="download">download</button>
    </div>
  </body>
</html>